<!DOCTYPE html>
<html class="no-js" lang="de-AT">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title> Getafix Player </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.71.1" />
    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,500,600,700,800' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap" rel="stylesheet">

    <!-- Stylesheets -->
    
    
    
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/vendor.min.55a3cbb6f035c25e5c7cf706ee053eca6f5a54d8095b05fd737d1b0330f99eaf.css">
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/css/animate.css">

    
    
    
    
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/style.min.9246c32f81630cb4abe3802eef0d4d83d9f42d87da060e42838b4966ccac6c7c.css">
</head>

<body id="body">
    <!-- NAVIGATION -->

<nav class="navbar fixed-top navbar-expand-lg navbar-light bg-light ">
    <div class="container-fluid">
        <a class="navbar-brand" href="/"><img src="/img/logo.png" height="30"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item ">
                    <a class="nav-link" href="/">Home</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/termine">Termine</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/info">Infos</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/mentoren">Mentoren</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/sponsoring">Sponsoring</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="/uebungsanleitungen">Übungsanleitungen</a>
                </li>
            </ul>
        </div>
    </div>
</nav>

    

    
    

     
<section id="sushi">
    <div class="container">
        <div class="row">
            
            <div class="col-12 sushi-content"> 

<h1 id="miraculix-der-druide-teil-1">Miraculix der Druide - Teil 1</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#long1">Ausführliche Anleitung /gethealth</a></li>
<li><a href="#long2">Ausführliche Anleitung /heal</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>Vielleicht hast du schon einmal Asterix und Obelix gelesen oder einen der Filme angesehen. Dann wirst du dich sicherlich an den Druiden Miraculix erinnern, das ist der, der den Zaubertrank zubereiten kann. Wir werden in dieser und einigen weiteren Episoden ein Plugin programmieren, mit dem du Miraculix spielen kannst. Wir fangen damit an, dass du dich und andere Spieler sofort heilen kannst. Auch kannst du deine Gesundheit oder die Gesundheit anderer Spieler anzeigen. Dazu soll es folgende Befehle geben:</p>
<pre><code>/gethealth me
/gethealth OidaZocktYT
/heal me
/heal OidaZocktYT</code></pre>
<p>Also im Grunde zwei Kommandos:</p>

<ul>
<li><code>/gethealth</code>: Zeigt die Gesundheit von mir (<code>me</code> als Parameter) oder eines anderen Spielers (Name des anderen Spielers als Parameter) an</li>
<li><code>/heal</code>: Heilt mich oder einen anderen Spieler</li>
</ul>

<p><img src="03_getafix-Player/Command.png" alt="How the command looks like" /></p>

<p>Wenn du dich wunderst, warum das Plugin nun <em>Getafix</em> heißt, verrate ich dir, dass auf Englisch der Druide nicht Miraculix sonder Getafix heißt. Und du hast sicher schon bemerkt, dass wir Informatiker gerne Dinge in englischer Sprache benennen. Daher kommt das. Jetzt kannst du deine Englischlehrerin oder deinen Englischlehrer abtesten, ob er oder sie die wirklich wichtige Literatur auch auf Englisch gelesen hat :-).</p>

<h3 id="grundsätzliche-überlegungen">Grundsätzliche Überlegungen</h3>

<p>Jetzt wollen wir mal überlegen, was wir zum Schreiben eines Plugins, welches die Gesundheit eines Spielers ausliest und verändert, brauchen und wie wir am besten vorgehen:</p>

<ol>
<li>Wir müssen bei der Eingabe von <code>/gethealth</code> die Gesundheit des Senders ermitteln. Dazu benötigen wir eine Möglichkeit, die Gesundheit des Spielers zu ermitteln. Du erinnerst dich, dass der Spieler im <code>onCommand</code> als Parameter <code>sender</code> ansprechbar ist. Da brauchen wir dann für diesen Sender eine Methode, die irgendwas mit <code>health</code> im Namen hat. Die werden wir, nachdem du das NetBeans-Projekt angelegt hast, suchen.</li>
<li>Damit es für den Anfang schön einfach bleibt, werden wir die Geschichte mit dem <code>me</code> oder dem Namen eines anderen Spielers noch lassen und nur auf den Befehl <code>/gethealth</code> oder <code>/heal</code> (so, wie in den Screenshots oben) reagieren und immer unsere eigene Gesundheit ausgeben oder uns selbst heilen.</li>
</ol>

<h3 id="neues-netbeans-projekt-anlegen">Neues NetBeans-Projekt anlegen</h3>

<p>Anfangen tut das Ganze mit bereits bekannten Arbeitsschritten. Wir legen ein Projekt an mit dem Namen <code>Getafix</code>. Dann legst du gleich ein Package mit dem Namen <code>getafix</code> an (vergiss nicht, vorher deinen Namen plus eine Domain anzugeben. Bei mir hieße das <code>com.bajupa.getafix</code>). Falls du dich nicht mehr ganz gut erinnern kannst, sieh einfach in der Episode 2 nach, wie wir ein neues Projekt und ein neues Package angelegt haben. Zum Schluss legen wir eine neue Klasse mit dem Namen <code>Getafix</code> an (achte bitte wieder auf die Groß- und Kleinschreibung). Kurz gesagt: du musst die ersten sechs Punkte der <em>Zusammenfassung für Profis</em> aus der zweiten Episode abgearbeitet haben.</p>

<p>Da das jetzt nicht mehr alles ganz neu ist für dich, wollen wir uns an dieser Stelle noch ein klein bisschen genauer umsehen. Du erinnerst dich, dass wir vom Parameter <code>sender</code> verschiedene Methoden aufrufen konnten (<code>sendMessage</code> und <code>getName</code> im letzten Fall). Vielleicht hast du das letzte Mal schon bemerkt, dass, sobald du nach <code>sender</code> einen Punkt eintippst, ein Menü erscheint, in welchem alle Methoden, die du hier aufrufen kannst, aufgelistet sind. Falls das nicht der Fall ist, kannst du mit <code>Strg</code> und <code>Space</code> (also die große Taste unten für das Leerzeichen) nachhelfen, dass das Menü auch wirklich kommt. Dann sollte das ganze ca. so aussehen. Probiere es gleich mal aus:</p>

<p><img src="03_getafix-Player/AvailableMethods.png" alt="Get menu of available methods and properties" /></p>

<p>Wenn du dich in dem Menü ein wenig umsiehst, kannst du alle verfügbaren Methoden für <code>sender</code> ansehen. Unter diesem Menü solltest du noch folgendes Fenster sehen.</p>

<p><img src="03_getafix-Player/MissingJavadoc.png" alt="Javadoc info with missing Javadoc" /></p>

<p>Das ist jetzt noch nicht sonderlich hilfreich, weil eine Fehlermeldung drinsteht. Das wollen wir ändern, dass da immer eine genauere Beschreibung der Methode, die du gerade ausgewählt hast, drinstehen. Dazu müssen wir die fehlende Dokumentation noch dazulinken. Dazu klickst du auf <code>Attach Javadoc...</code> und im darauffolgenden Fenster klickst du zuerst auf <strong>Add URL&hellip;</strong> und dann tippst du <code>https://hub.spigotmc.org/javadocs/bukkit/</code> bei <strong>Remote Javadoc URL</strong> ein.</p>

<p><img src="03_getafix-Player/SelectJavadoc.png" alt="Javadoc info with missing Javadoc" /></p>

<p>Nun solltest du für jede Methode eine kurze Beschreibung bekommen. Ich weiß ja nicht, wie es dir geht, aber zum Thema Gesundheit kann ich beim <code>sender</code> kein wirkliches Angebot finden. Damit wir hier weiterkommen, muss ich dir noch kurz eine Geschichte erzählen. Dauert auch nicht lange, versprochen:</p>

<h3 id="über-menschen-berufe-variablen-parameter-und-datentypen">Über Menschen, Berufe, Variablen, Parameter und Datentypen</h3>

<p>In der letzten Episode, als wir das erste Plugin geschrieben haben, war ich ein bisschen schlampig bei meinen Erklärungen. Du erinnerst dich sicher noch an den Parameter <code>sender</code>, mit dem wir die Spielerin, die das Kommando eingetippt hat &ldquo;ansprechen&rdquo; konnten und ihr eine Nachricht mit Hilfe der Methode <code>sendMessage</code> senden konnten.</p>

<p>Ja gut und ich habe dir gar nicht gesagt, warum das so funktioniert, weil ich wollte, dass wir ganz schnell unser Plugin fertig bekommen. Diese Sache hole ich jetzt nach. Du erinnerst dich ja noch, dass die leere Methode <code>onCommand</code> so ausgesehen hat:</p>
<pre><code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    return true;
}</code></pre>
<p>Wir haben dann gesagt, dass in den runden Klammern die Parameter stehen, damit man der Methode bestimmte Informationen, die sie zum Arbeiten braucht, &ldquo;mitgeben&rdquo; kann. So wie oben den Sender des Kommandos, also den, der das Kommando eingetippt hat.</p>

<p>Dabei ist nun folgendes zu beachten: <code>sender</code> ist der <em>Name</em> des Parameters und <code>CommandSender</code> der <em>Typ</em> des Parameters. Das ist ein bisschen so, wie im echten Leben mit den Menschen und ihren Berufen. Beispielsweise könnten wir sagen, dass in dem Falle, dass irgendwo gearbeitet wird, wir einen Tischler und einen Programmierer brauchen. &ldquo;Anton ist ein Tischler&rdquo; und &ldquo;Sophia ist eine Programmiererin&rdquo;. In Java-Notation könnte das dann so aussehen:</p>
<pre><code>public boolean onWork(Joiner anton, Programmer sophia) {
    return true;
}</code></pre>
<p>Also <code>onWork</code> ist der Name der Methode und <code>anton</code> und <code>sophia</code> sind die Parameter. Wir werden noch eine andere Schreibweise kennenlernen:</p>
<pre><code>Joiner anton;
Programmer sophia;</code></pre>
<p>Das werden wir dann verwenden, wenn wir in einer Methode kurz mal jemanden mit einem bestimmten Beruf benötigen (äh, einen Namen mit einem bestimmten Typ natürlich). In diesem Fall sagen wir nicht <em>Parameter</em> sondern <em>Variable</em>, sonst ist es aber das gleiche.</p>

<p>Ja, Java ist eine etwas schlichte Sprache, aber so ist das nun mal. Außerdem schreiben wir Namen in Java immer klein, dafür die &ldquo;Berufe&rdquo; (eigentlich sprechen wir von Datentypen) immer groß. Auf unser Beispiel oben angewendet können wir jetzt sagen &ldquo;<code>sender</code> ist ein <code>CommandSender</code>&rdquo;.</p>

<p>Wie im echten Leben auch, können wir Menschen mit unterschiedlichen Berufen unterschiedliche &ldquo;Befehle&rdquo; geben. Einem Tischler können wir sagen &ldquo;baue mir bitte ein Wohnzimmer&rdquo; und er wird das machen können. Eine Programmiererin können wir bitten &ldquo;schreibe mir ein Minecraft-Plugin&rdquo;. In Java würde das vielleicht dann so aussehen</p>
<pre><code>Joiner anton;
Programmer sophia;

anton.buildLivingRoom();
sophia.writeMinecraftPlugin();</code></pre>
<p>Habe ich schon erwähnt, dass Java (wie die meisten Programmiersprachen) sehr schlicht ist und nicht viel Platz für Höflichkeitsfloskeln lässt? Also zusammengefasst: Welche Befehle ich einer Person (sinnvoll) geben kann, hängt von ihrem Beruf ab. In Informatikersprache heißt das: Welche Methoden ich bei einer Variable (Parameter) aufrufen kann hängt von ihrem (seinem) Datentyp ab.</p>

<p>Jetzt, da du das verstanden hast, kannst du dir auch vorstellen, dass du den Namen <code>sender</code> im <code>onCommand</code> ändern kannst, ohne dass die Funktionalität leiden würde. Wie im echten Leben kannst du deine Kinder nennen, wie du magst. Wenn du aber den Datentyp <code>CommandSender</code> ändern würdest, dann würde plötzlich nix mehr funktionieren, weil das <code>onCommand</code> als ersten Parameter einen <code>CommandSender</code> erwartet. Wieder hilft uns das echte Leben: Wenn du neue Möbel für dein Wohnzimmer brauchst, dann willst du einen Tischler und keinen Programmierer.</p>

<h2 id="a-name-long1-a-ausführliche-anleitung-gethealth"><a name="long1"></a>Ausführliche Anleitung /gethealth</h2>

<p>Wir beginnen mit einem einfachen Fall. Sobald der Spieler <code>/gethealth</code> im Spiel eingibt, soll die Gesundheit als Zahl zwischen 0 und 20 ausgegeben werden. Also sehen wir uns den Typ des Parameters <code>sender</code> einmal an. Das ist ein <code>CommandSender</code> und wenn du nun <code>sender.</code> in einer Zeile der Methode <code>onCommand</code> eintippst, dann siehst du, was so ein <code>CommandSender</code> alles kann. Du wirst feststellen, dass der aber mit Gesundheit nix am Hut hat, weil wir keine Methode finden, die irgendwo &ldquo;Health&rdquo; im Namen hat. Aber es gibt einen anderen Datentypen, nämlich <code>Player</code>, der den Spieler in einem Minecraft-Game genauer spezifiziert. Genauer gesagt ist ein <code>Player</code> auch ein <code>CommandSender</code>und kann aber noch um einiges mehr. Du kannst das ausprobieren, indem du folgendes eintippst:
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>Player player;</b>
        <b>player.</b>
        return true;
    }
</pre></p>

<p>Jetzt sollte das Menü mit den verfügbaren Methoden ein wenig länger sein. Du findest auch alle Methoden vom <code>CommandSender</code> wieder und eben noch mehr. Besonders auffallen sollten dir die Methoden <code>getHealth</code> und <code>setHealth</code>.</p>

<p>Wenn also der <code>sender</code> nicht nur ein <code>CommandSender</code> sondern auch ein <code>Player</code> ist (und das ist er auf jeden Fall, wenn ein Spieler unser Command <code>/gethealth</code> eingibt), dann könnten wir auf das viel umfangreichere Methodenangebot von <code>Player</code> zurückgreifen. Dazu brauchen wir nur noch einen Trick, wie wir aus einem <code>CommandSender</code> einen <code>Player</code> machen können. Dazu legen wir uns eine Variable vom Type <code>Player</code> an und weisen ihr den sender zu. Das sieht dann folgendermaßen aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>Player player = sender;</b>
        return true;
    }
</pre>

<p>Du wirst aber sehen, dass der Compiler noch nicht einverstanden ist. <code>incompatible types: CommandSender cannot be converted to Player</code> meint er und hat aber auch gleich mehrere Lösungsvorschläge. Wir nehmen den ersten, also wir <em>casten</em> den <code>sender</code> in einen <code>Player</code>.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        Player player = <b>(Player)</b>sender;
        return true;
    }
</pre>

<p>Nun ist die Variable <code>player</code> der Player, welcher das Kommando abgeschickt hat und wir haben den vollen Zugriff auf alle Methoden von <code>Player</code>. Und das nutzen wir gleich schamlos aus und geben die Gesundheit des Spielers aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        Player player = (Player) sender;
        <b>sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());</b>
        return true;
    }
</pre>

<p>Jetzt fehlt uns noch das <code>plugin.yml</code>:</p>
<pre><code>## YAML Template.
---
name: Getafix
main: com.bajupa.getafix.Getafix
version: 0.1.0
authors:
    - P. Bauer
description: A miraculous healing plugin.
commands:
    gethealth:
        description: Displays health level of player.
        usage: /gethealth &lt;player name&gt;</code></pre>
<p>Damit kannst du das Plugin nun bauen und aus dem <code>dist</code> Verzeichnis in dein Testserver-Verzeichnis kopieren, den Server starten und dich dann von deinem Minecraft-Client aus mit deinem Server verbinden.</p>

<p>Als erstes achte darauf, dass du im survival mode bist (unten am Schirm sind Herzen und Becher zu sehen, die deine Gesundheit und deine Sättigung anzeigen). Wenn du das nicht siehst, dann tippe als erstes das Kommando <code>/gamemode 0</code> ein. Probiere gleich aus, wie dein health level ist, indem du <code>/gethealth</code> eintippst. Dann lass dich von einem größeren Blockhaufen runterfallen oder mach sonst etwas, das deine Gesundheit verschlechtert und gib das Kommando nochmals ein.</p>

<h3 id="eine-notwendige-erweiterung">Eine notwendige Erweiterung</h3>

<p>Wir können ja alle Minecraft-Befehle (also auch die von Plugins) in der Server-Konsole eintippen. Das probierst du am besten auch gleich aus. Achte darauf, dass in diesem Fall <strong>kein</strong> Schrägstrich davorkommt.</p>

<p>Und hast du schon probiert? Da haben wir nämlich jetzt den Salat und der heißt <em>Exception</em>. Wenn eine Exception passiert, dann heißt das immer, dass der Programmierer Mist gebaut hat und das wollen wir ja nun wirklich nicht auf uns sitzen lassen. Daher schauen wir uns das mal ein wenig genauer an:</p>
<pre><code>[16:32:03 WARN]: Unexpected exception while parsing console command &#34;gethealth&#34;
org.bukkit.command.CommandException: Unhandled exception executing command &#39;gethealth&#39; in plugin FirstPlugin v0.1.0
at org.bukkit.command.PluginCommand.execute(PluginCommand.java:46) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.command.SimpleCommandMap.dispatch(SimpleCommandMap.java:141) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchCommand(CraftServer.java:640) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchServerCommand(CraftServer.java:626) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.DedicatedServer.aO(DedicatedServer.java:411) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.DedicatedServer.B(DedicatedServer.java:375) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.MinecraftServer.A(MinecraftServer.java:653) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.MinecraftServer.run(MinecraftServer.java:556) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at java.lang.Thread.run(Thread.java:745) [?:1.8.0_31]
Caused by: java.lang.ClassCastException: org.bukkit.craftbukkit.v1_8_R3.command.ColouredConsoleSender cannot be cast to org.bukkit.entity.Player
at com.bajupa.getafix.Getafix.onCommand(Getafix.java:39) ~[?:?]
at org.bukkit.command.PluginCommand.execute(PluginCommand.java:44) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
... 8 more</code></pre>
<p>Da braucht man durchaus gute Magennerven um durch diese Lawine an Kauderwelsch durchzugraben. Daher gebe ich dir den Tipp, in der siebten Zeile von unten, bei der Stelle, die mit <em>Caused by:</em> anfängt, mit dem Lesen zu beginnen.</p>

<p><code>org.bukkit.craftbukkit.v1_8_R3.command.ColouredConsoleSender cannot be cast to org.bukkit.entity.Player</code> steht da und weiters <code>at com.bajupa.getafix.Getafix.onCommand(Getafix.java:39)</code>. Der erste Teil sagt uns, dass wir <code>ColouredConsoleSender</code> nicht in einen <code>Player</code> casten können. Das ist ja auch verständlich, weil die Console halt wirklich kein Player ist. Der zweite Teil sagt uns, dass der Schlamassel in Zeile 39 passiert ist. Vielleicht steht da bei dir eine andere Zeilennummer. Wenn du jedenfalls im NetBeans auf die Zeilennummer, die bei dir steht schaust, dann siehst du, dass das (wenig überraschend) die Zeile <code>Player player = (Player) sender;</code> ist. Wenn deine Plugins größer werden, kann das aber sehr hilfreich sein, wenn du hier rauslesen kannst, in welcher Zeile dein Fehler passiert ist.</p>

<p>Also Houston, wir haben ein Problem: Wenn jemand in der Console seine eigene Health abrufen will, muss das unweigerlich in die Hose gehen. Wie lösen wir das? Was brauchen wir zur Lösung?</p>

<ol>
<li>Wir müssen eine Möglichkeit haben um rauszufinden, ob der <code>sender</code> vom Datentyp <code>Player</code> ist.</li>
<li>Wir dürfen unseren code nur dann ausführen, wenn der <code>sender</code> vom Datentyp <code>Player</code> ist</li>
<li>Freundlich wäre, wenn wir, falls der <code>sender</code> <strong>nicht</strong> vom Datentyp <code>Player</code> ist, dem <code>sender</code> mitteilten, dass er eben kein <code>Player</code> ist und deswegen er keine Gesundheitsdaten hat, der Arme.</li>
</ol>

<p>Zum Glück gibts für alle drei Dinge eine Lösung. Also der Reihe nach:
<ol>
<li> <code>sender instanceof Player</code> ist eine Aussage, die eindeutig mit wahr oder falsch beantwortet werden kann (so ähnlich wie &ldquo;jetzt scheint die Sonne&rdquo;). Wenn ein Spieler im Spiel unser Command aufruft, ist <code>sender instanceof Player</code> wahr (auf Englisch <code>true</code>), wenn jemand in der Console unser Command aufruft ist <code>sender instanceof Player</code> aber falsch (auf Englisch <code>false</code>)</li></p>

<p><li>Wenn wir Code ausführen wollen, der nur im Fall, wenn die Aussage <code>sender instanceof Player</code> wahr ist dann gibt es in Java das schöne Wort <code>if</code>. Insgesamt sieht das dann so aus:</p>

<pre>
if (sender instanceof Player) {
}
</pre>

<p>Achte darauf, dass die Aussage (meistens sagen wir einfach die Bedingung) in einem runden Klammernpaar geschrieben werden muss (so ähnlich wie die Parameter einer Methode). Zwischen den geschwungenen Klammern kommt dann der Code, der ausgeführt werden soll, wenn die Bedingung wahr ist.
</li></p>

<p><li>Für den Fall, dass die Aussage nicht wahr ist, und wir in diesem Fall anderen Code ausführen wollen, gibt es das Wort <code>else</code>. Alles zusammen sieht das dann so aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (sender instanceof Player) {</b>
            Player player = (Player) sender;
            sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        <b>}</b>
        <b>else {
            sender.sendMessage("Poor guy you are no player -> no health data available");
            return false;
        }</b>
     }
</pre>
</li>
</ol>
Gut, dann bauen und testen!

## <a name="long2"></a>Ausführliche Anleitung /heal

### Das yml-file erweitern
Wir müssen unser Plugin so umschreiben, dass es nun auf zwei verschiedene Kommandos reagiert. Beginnen wir einmal damit, dass es überhaupt auf ein weiteres Kommando reagiert. Dazu erweitern wir das `plugin.yml`.

<pre>
    ## YAML Template.
    ---
    name: Getafix
    main: com.bajupa.getafix.Getafix
    version: 0.<b>2</b>.0
    authors:
        - P. Bauer
    description: A miraculous healing plugin.
    commands:
        gethealth:
            description: Displays health level of player.
            usage: /gethealth me | player-name
        <b>heal:
            description: Brings your health to the top level.
            usage: /heal me | player-name
        </b>
</pre>

<p>Wir probieren das gleich aus, ob es funktioniert. Also baust du und dann kannst du in deinem Testserver-Verzeichnis einen weiteren Ordner namens <strong>update</strong> anlegen und dort kopierst du nun das <code>Getafix.jar</code> rein. Wenn dein Server vom letzten Test noch läuft, dann tippst du in der Konsole einfach <code>reload</code> ein und das neue jar-File wird geladen. Du erkennst es daran, dass das <strong>update</strong>-Verzeichnis nun leer ist. Wenn du nun <code>heal</code> in die Konsole eintippst bekommst du die Fehlermeldung, dass du in der Konsole keine Gesundheitsdaten zur Verfügung hast. Das ist noch nicht ideal, aber logisch, weil ja noch nix programmiert wurde. Wir sehen aber, dass unser Plugin schon mal auf den neuen Befehl reagiert.</p>

<h3 id="wieder-ein-paar-überlegungen">Wieder ein paar Überlegungen</h3>

<p>Nun müssen wir uns überlegen, was wir eigentlich wollen.</p>

<ol>
<li>Wir wollen unterscheiden, welches Kommando der Sender jetzt eingetippt hat. Dazu können wir einen weiteren Parameter, nämlich <code>label</code> verwenden.</li>
<li>Wir wollen, je nachdem, welches Kommando eingegeben wurde, unterschiedliche Code-Teile ausführen. Da klingelt&rsquo;s wahrscheinlich schon: das wird wieder einmal ein Fall für unser <code>if</code>.</li>
</ol>

<p>Naja, das sieht ja schon ganz gut aus.</p>

<h3 id="erste-code-erweiterungen">Erste Code-Erweiterungen</h3>

<p>Als erstes sehen wir uns die Sache mit dem <code>label</code> an. Du erinnerst dich? <code>label</code> ist der Name und <code>String</code> ist der Datentyp. <code>String</code>s sind Zeichenketten, das hatten wir schon mal bei der Methode <code>sendMessage</code>, der wir einen Text zum Anzeigen mitgegeben haben und das war auch der mit dem + zum Aneinanderkleben von mehreren Strings. So ein String kann aber noch mehr.</p>

<p>Als erstes sehen wir uns aber an, ob im <code>label</code> auch wirklich das Kommando drinnensteht. Da wir mit <code>sendMessage</code> eine Methode haben, einen String auszugeben benutzen wir das gleich mal:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>sender.sendMessage("Label: " + label);</b>
        if (sender instanceof Player) {
            Player player = (Player) sender;
            sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        }
        else {
            sender.sendMessage("Poor guy you are no player -> no health data available");
            return false;
        }
     }
</pre>

<p>Wenn du das jetzt baust und das jar neu lädst müsste bei Aufruf von <code>/gethealth</code> oder auch <code>/heal</code> immer das Kommando, das du eingegeben hast, ausgegeben werden. Naja, damit haben wir doch schon mal unser Unterscheidungskriterium. Jetzt wollen wir das ganze in ein <code>if</code> verpacken und dann haben wir wieder schön unterscheidbare Code-Teile, die je nach Eingabe ausgeführt werden.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (label.equalsIgnoreCase("gethealth")) {</b>
            if (sender instanceof Player) {
                Player player = (Player) sender;
                sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
                return true;
            }
            else {
                sender.sendMessage("Poor guy you are no player -> no health data available");
                return false;
            }
        <b>}
        else {
            sender.sendMessage("Healing will be done later, sorry");
            return true;
        }</b>
     }
</pre>

<p>Gut, das <code>label.equalsIgnoreCase(&quot;gethealth&quot;)</code> ist vielleicht noch eine kleine Erklärung wert: Also, wir wissen, dass <code>label</code> vom Datentyp <code>String</code> ist und Strings können ein paar Dinge (Denke wieder an die Berufe). Eines davon ist sich selbst mit einem anderen String zu vergleichen. Das ist <code>equals</code>, welches ein <code>true</code> (wahr) zurückgibt, wenn der String, der als Parameter mitgegeben wird gleich ist und <code>false</code>, wenn nicht.</p>

<p>Das <code>equals</code> achtet aber auf Groß- und Kleinschreibung und damit würde das Kommando <code>/getHealth</code> nicht mehr erkannt werden (<code>equals</code> würde <code>false</code> zurückgeben). Damit das nicht passiert, gibt es <code>equalsIgnoreCase</code>, das eben über Groß- und Kleinschreibschwächen hinwegsieht.</p>

<p>Zum Schluss dieser Episode wollen wir noch den Code einfügen, der eigentlich gemacht werden soll, wenn der Spieler <code>/heal</code> eingibt. Wie immer dazu &hellip;</p>

<h3 id="ein-paar-weitere-kleine-überlegungen">Ein paar weitere kleine Überlegungen</h3>

<ol>
<li>Wie bei <code>gethealth</code> werden wir diese Überprüfung mit <code>instanceof Player</code> brauchen und dann wieder den <code>sender</code> auf einen <code>Player</code> casten (merkst du, dass wir schon wie echte Informatiker sprechen, das heißt, dass dich deine Großeltern sicher nimmer verstehen).</li>
<li>Wir brauchen eine Methode von <code>Player</code>, um dessen Gesundheit zu verändern. Das ist die Methode <code>setHealth</code>.</li>
</ol>

<p>###Letzte Code-Erweiterung
Da habe ich jetzt einen Vorschlag. Das probierst du jetzt schnell mal selber. Die Mentoren können dir dabei helfen. Außerdem gibt es in der nächsten Episode natürlich die Auflösung. Viel Spaß</p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>Neues Projekt anlegen: Menüpunkt <strong>File</strong> &gt; <strong>New Project</strong>, in Choose Project: <strong>Java</strong> &gt; <strong>Java Class Library</strong> mit Projektnamen <code>GetafixPlugin</code></li>
<li><code>craftbukkit.jar</code> zu den Libraries dazufügen: Rechte Maus-Klick auf <strong>Libraries</strong> &gt; <strong>Add JAR/Folder</strong></li>
<li>Package anlegen: Rechte Maus-Klick auf <strong>Source Packages</strong>, Auswahl von <strong>New</strong> &gt; <strong>Java Package</strong> mit Package Name z.B. <code>io.coderdojo.&lt;dein-name&gt;.getafix</code></li>
<li>Klasse anlegen: Rechte Maus-Klick auf das eben erstellte Package, Auswahl von <strong>New</strong> &gt; <strong>Java Class</strong> mit Class Name z.B. <code>GetafixPlugin</code></li>
<li><code>extends JavaPlugin</code> nach dem Klassennamen dazuschreiben</li>
<li>Methode <code>onCommand</code> generieren: Rechte Maus-Klick im Editor zwischen den geschwungenen Klammern &gt; <strong>Inserter Code</strong> &gt; <strong>Override Method</strong> &gt; Auswahl von <code>onCommand</code> &gt; <strong>Generate</strong></li>
<li>Die Methode ausprogrammieren, also reinschreiben, was geschehen soll, wenn eines der Kommandos aufgerufen wird:
<pre>
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    if (label.equalsIgnoreCase(&ldquo;gethealth&rdquo;)) {
        if (sender instanceof Player) {
            Player player = (Player) sender;
            player.sendMessage(&ldquo;Health of &rdquo; + player.getName() + &ldquo;: &ldquo; + player.getHealth());
            return true;
        } else {
            sender.sendMessage(&ldquo;Poor guy you are no player -&gt; no health data available&rdquo;);
            return false;
        }
    } else {
        //Aufgabe 1: Stelle sicher, dass nur Spieler geheilt werden können.
        //Aufgabe 2: Heile den Spieler, wenn du weißt dass du die Methode <code>setHealth</code> für den <code>player</code> aufrufen musst?
        //Aufgabe 3: Schreibe dem Spieler, dass du ihn geheilt hast, einmal auf der Minecraft Console, und einmal als Log Statement
        return true;
    }
}
</pre></li>
<li><code>plugin.yml</code> zum Projekt hinzufügen: Rechte Maus-Klick auf <strong>Source Packages</strong> &gt; <strong>New</strong> auswählen &gt; <strong>YAML File</strong> mit File Name <code>plugin</code></li>

<li><p>Die Details im <code>plugin.yml</code> eingeben, wobei du die Details in den eckigen Klammern [] durch deine Werte ersetzt:
<pre></p>

<h2 id="yaml-template">YAML Template.</h2>

<hr />

<p>name: Getafix
main: [Package Name].[Class Name]
version: 0.1.0
author: [dein Name]
description: A miraculous healing plugin.
commands:
    gethealth:
        description: Displays health level of player.
        usage: /gethealth player-name
    heal:
        description: Brings your health to the top level.
        usage: /heal me | player-name
</pre></p></li>

<li><p>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</p></li>

<li><p>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</p></li>

<li><p>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</p></li>

<li><p>Teste das Plugin indem du in Minecraft deine Kommandos <code>/gethealth</code> und <code>/heal</code> aufrufst.</p></li>
</ol>
 </div>
        </div>
    </div>
</section> 

    <footer>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <p>
                        Coding Club Linz,
                        Birkenweg 16,
                        4060 Leonding
                        <br />
                        <a href="mailto:info@linz.coderdojo.net">info@linz.coderdojo.net</a>
                    </p>
                </div>
            </div>
        </div>
    </footer>


    <!-- Js -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="https://linz-preview.coderdojo.net/js/wow.min.js"></script>
    <script src="https://linz-preview.coderdojo.net/js/main.js"></script>

</body>

</html>