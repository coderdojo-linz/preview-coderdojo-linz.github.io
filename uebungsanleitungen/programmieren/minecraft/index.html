<!DOCTYPE html>
<html class="no-js" lang="de-AT">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title> Minecraft </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.71.1" />
    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,500,600,700,800' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap" rel="stylesheet">

    <!-- Stylesheets -->
    
    
    
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/vendor.min.55a3cbb6f035c25e5c7cf706ee053eca6f5a54d8095b05fd737d1b0330f99eaf.css">
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/css/animate.css">

    
    
    
    
    <link rel="stylesheet" href="https://linz-preview.coderdojo.net/style.min.f5b53262f7ae54a74cab5e2c495d70dd05173f435ab7af1be0740f43e6e5e4fc.css">
    <script src="https://kit.fontawesome.com/5bb5b2cc9c.js" crossorigin="anonymous"></script>
</head>

<body id="body">
    <!-- NAVIGATION -->

<nav class="navbar fixed-top navbar-expand-lg navbar-light bg-light ">
    <div class="container-fluid">
        <a class="navbar-brand" href="/"><img src="/img/logo.png" height="30"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item ">
                    <a class="nav-link" href="/">Home</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/termine">Termine</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/info">Infos</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/mentoren">Mentoren</a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/sponsoring">Sponsoring</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="/uebungsanleitungen">Übungsanleitungen</a>
                </li>
            </ul>
        </div>
    </div>
</nav>

    

    
    

    

<section id="exercises" class="exercises">
    <div class="container-fluid breadcrumb-container">
    <div class="container">
        <nav class="breadcrumb-nav" aria-label="breadcrumb">
        <ol class="breadcrumb">
            
        
        
        
        
        
        
        

        
        
        

        
        
        <li class="breadcrumb-item">
            <a href="https://linz-preview.coderdojo.net/uebungsanleitungen/">Übungsanleitungen</a>
        </li>
        
        
        
        

        
        
        <li class="breadcrumb-item">
            <a href="https://linz-preview.coderdojo.net/uebungsanleitungen/programmieren/">Programmieren</a>
        </li>
        
        
        
        

        
        
        
        
        </ol>

        
        </nav>
    </div>
</div>

    <div class="container">
        <div class="row">
            <div class="col">
                <h1>Minecraft</h1>
            </div>
        </div>
        <div class="row row-cols-1 row-cols-md-3">
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/02_first-plugin\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Dein erstes Plugin</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Übung wirst du dein erstes Minecraft-Plugin erstellen, das dich auf Kommando begrüßt</h6>
                        <p class="card-text mt-4">

<h1 id="dein-erstes-plugin-sayhello">Dein erstes Plugin /sayhello</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#project">Neues NetBeans-Projekt</a></li>
<li><a href="#long">Ausführliche Anleitung</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>Nach den Vorbereitungsarbeiten können wir nun endlich unser erstes Plugin entwickeln. Wenn wir mit dieser Episode fertig sind, wirst du in Minecraft den Befehl <code>/sayhello</code> eingeben können und du wirst eine Antwort erhalten und er wird dich sogar mit deinem Minecraft-Namen ansprechen.</p>

<p><img src="02_first-plugin/Command.png" alt="Command screenshot" /></p>

<p>Dieses wird vielleicht noch nicht das absolute Killer-Plugin auf <em>Curse</em> sein aber eine Reise beginnt immer mit ihrem ersten Schritt. Also, los gehts:</p>

<h2 id="a-name-project-a-ein-neues-netbeans-projekt-anlegen"><a name="project"></a>Ein neues NetBeans-Projekt anlegen</h2>

<p>Als erstes starten wir natürlich NetBeans. Die StartPage brauchen wir nicht und du kannst sie gleich wegklicken. Jetzt gehst du ins Menü <strong>File</strong> und findest als ersten Menüpunkt <strong>New Project …</strong> Wenn du den auswählst, siehst du folgendes Fenster:</p>

<p><img src="02_first-plugin/ChooseProject.png" alt="Choose Project" /></p>

<p>Du wählst die Kategorie <strong>Java</strong> und von den Projekten <strong>Java Class Library</strong>, anschließend klickst du auf <strong>Next &gt;</strong>. Damit siehst du sofort ein weiteres Fenster, das folgendermaßen aussieht:</p>

<p><img src="02_first-plugin/NameAndLocateProject.png" alt="Name and locate project" /></p>

<p>Hier vergibst du einen sinnvollen Projektnamen. Da es unser erstes Plugin ist, tut es auch ein etwas einfallsloses <strong>FirstPlugin</strong>, besser verständlich ist natürlich ein Name wie <strong>GreetMe</strong>. Für die <strong>Project Location</strong> suchst du dir einen Platz auf deiner Festplatte, wo du das Plugin auch wiederfindest. <strong>Project Folder</strong> lässt sich nicht ändern. Dieses Feld zeigt dir nur, wo dein Projekt und alle seine Files gespeichert werden. Damit bist du fertig und kannst auf den Button <strong>Finish</strong> drücken. Damit verschwindet das Fenster und du hast einen ersten Blick auf dein gesamtes Projekt.</p>

<p>So nun wollen wir uns mal ein wenig orientieren.</p>

<p><img src="02_first-plugin/NetBeansOverview.png" alt="NetBeans Overview" /></p>

<p>Der Arbeitsbereich in NetBeans gliedert sich grundsätzlich in 5 Teile. Wir gehen diese nummernweise durch:</p>

<ol>
<li>Im <em>Project Explorer</em> hast du einen Überblick über dein Projekt. Alle Dateien, die du dazu brauchst sind hier aufgelistet und können relative schnell gefunden werden. Die wichtigsten Files wirst du unter <strong>Source Packages</strong> finden.</li>
<li>Im <em>Navigator</em> wirst du, nachdem wir das erste File editieren, einen Überblick über das geöffnete File haben. Wenn das File ein wenig größer wird, wirst du sehen, dass es sehr bequem ist, wenn man schnell zu bestimmten Punkten im File springen kann.</li>
<li>Im <em>Information Panel</em> bekommst du Informationen, die beim Arbeiten wichtig sind. Beispielsweise kannst du hier sehen, ob du dein Projekt erfolgreich &ldquo;baut&rdquo;, das heißt für den Einsatz in Minecraft übersetzt werden kann.</li>
<li>Das ist der <em>Editor</em>. Hier werden wir dann Java-Code reinschreiben</li>
<li>Das ist die <em>Toolbar</em>. Manche Befehle (z. B. um das Projekt zu bauen) können wir hier schnell erreichen.</li>
</ol>

<p>Bevor wir jetzt endlich mit dem Programmieren beginnen, müssen wir noch die Datei <code>craftbukkit.jar</code> zu unserem Projekt hinzufügen. Ja du liest richtig, es ist genau dieselbe Datei, die wir bereits verwendet haben, um unseren Server zu starten. Am besten legst du dir eine Kopie an und legst sie im Ordner neben deinem FirstPlugin ab. Nun klickst du im <strong>Project Explorer</strong> mit der rechten Maustaste auf den Ordner <strong>Libraries</strong> und wählst den Punkt <strong>Add JAR/Folder…</strong> aus:</p>

<p><img src="02_first-plugin/AddJarStep1.png" alt="Add JAR Step 1" /></p>

<p>Nun siehst du folgendes Fenster in welchem du zum File <code>craftbukkit.jar</code> navigieren kannst. Wähle es aus und klicke auf <strong>Choose</strong>.</p>

<p><img src="02_first-plugin/AddJarStep2.png" alt="Add JAR Step 2" /></p>

<p>Jetzt siehst du im <strong>Project Explorer</strong> im Ordner <strong>Libraries</strong> die Datei <code>craftbukkit.jar</code>. So jetzt können wir mit dem Programmieren beginnen.</p>

<h3 id="großeltern-imponier-wissen">Großeltern-Imponier-Wissen</h3>

<ul>
<li>Java-Programme müssen, bevor sie ausgeführt werden können, <em>gebaut</em> werden. Das heißt, dass man den Java-Code (also das, was du schreibst) in einen Maschinen-Code (also das, was ein Computer ausführen kann) umwandeln muss. Manchmal sagt man auch, dass das Programm <em>compiliert</em> werden muss.</li>
<li>Wenn du ein Minecraft-Plugin schreibst, brauchst du Informationen vom Server (z. B. den Namen des Spielers) oder willst auch das Verhalten des Servers teilweise verändern (z. B. soll er auf das Kommando <code>/sayhello</code> reagieren, was er ja sonst mal so nicht täte). Damit das möglich ist, gibt es das sogenannte <em>API</em> (<strong>A</strong>pplication <strong>P</strong>rogrammer <strong>I</strong>nterface), das sind alle &ldquo;Funktionen&rdquo;, die der Server für dich zum Programmieren zur Verfügung stellt. Damit wir das API zur Verfügung haben, fügen wir die Datei <code>craftbukkit.jar</code> zu unserem Projekt dazu.</li>
</ul>

<h2 id="a-name-long-a-ausführliche-anleitung"><a name="long"></a>Ausführliche Anleitung</h2>

<h3 id="ein-package-und-die-plugin-klasse-anlegen">Ein Package und die Plugin-Klasse anlegen</h3>

<p>Du speicherst Java-Dateien in <em>Packages</em> ab. Wenn du im <strong>Project Explorer</strong> den Ordner <strong>Source Packages</strong> öffnest, siehst du das Package <strong>&lt;default package&gt;</strong>. Damit Package-Namen aber sicherlich eindeutig sind, legst du besser ein neues Package an, mit <code>io.coderdojo-linz.&lt;dein-name&gt;.firstplugin</code> (dabei ersetzt du <code>&lt;dein-name&gt;</code> durch deinen Namen). Wenn du eine eigene Domain über die du im Netz erreichbar bist hast, dann kannst du auch die verwenden.</p>

<p>Also klickst du mit der rechten Maustaste auf <strong>Source Packages</strong> und wählst aus dem Kontextmenü <strong>New</strong> und dann <strong>Java Package &hellip;</strong> aus.</p>

<p><img src="02_first-plugin/NewPackageStep1.png" alt="New Package Step 1" /></p>

<p>Im nun folgenden Fenster gibst du den Namen deines Packages, wie wir oben beschrieben haben, ein und klickst auf den Button <strong>Finish</strong>.</p>

<p><img src="02_first-plugin/NewPackageStep2.png" alt="New Package Step 1" /></p>

<p>Jetzt ist das Package <strong>&lt;default package&gt;</strong> verschwunden. Das macht nichts, weil wir es derzeit echt nicht brauchen. Und nun musst du noch die Klasse anlegen, in der wir dieses Plugin programmieren. Dazu (Überraschung!!) klickst du mit der rechten Maustaste auf das neu erstellte Package und wählst dann <strong>New</strong> und <strong>Java Class&hellip;</strong> aus</p>

<p><img src="02_first-plugin/NewClassStep1.png" alt="New Class Step 1" /></p>

<p>Im darauffolgenden Fenster gibst du der neuen Klasse einen Namen und klickst auf <strong>Finish</strong>.</p>

<p><img src="02_first-plugin/NewClassStep2.png" alt="New Class Step 2" /></p>

<p>Jetzt solltest du in NetBeans ziemlich genau dieses Bild vor dir haben:</p>

<p><img src="02_first-plugin/NewClassStep3.png" alt="New Class Step 2" /></p>

<p>Die grauen Zeilen am Anfang des Files sehen wahrscheinlich ein wenig anders aus. Das macht aber nix, weil das ist ein Kommentar und Kommentare werden vom Compiler ignoriert. Man verwendet Kommentare, um etwas in sein Programm reinzuschreiben, das für Menschen wichtig ist, aber nicht für Computer. Du kannst das ausprobieren und in einer Zeile <em>außerhalb</em> eines Kommentars folgende Zeilen dazuschreiben:</p>
<pre><code>/*
Ich kann so schreiben wie ich bin. Du darfst.
*/</code></pre>
<p>Wenn du jetzt aber die Zeichen <code>/*</code> und <code>*/</code> wegnimmst, dann wirst du sehen, dass der Text, den du geschrieben hast, rot unterstrichen ist und das bedeutet, dass der Compiler in deinem Java-Programm einen Fehler entdeckt hat. Also schließen wir daraus, dass mit <code>/*</code> ein Kommentar beginnt und so lange ist, bis die Zeichen <code>*/</code> vorkommen.</p>

<h3 id="die-klasse-programmieren">Die Klasse programmieren</h3>

<p>Nun musst du dieser Klasse als erstes mal mitteilen, dass sie ein Plugin werden soll. Das machst du indem du in der Zeile mit <code>public class FirstPlugin {</code> folgendes dazuschreibst:</p>

<p><img src="02_first-plugin/ExtendJavaPlugin.png" alt="Extend class to JavaPlugin" /></p>

<p>Du siehst nun, dass das Wort <code>JavaPlugin</code> rot unterstrichen ist und am Beginn der Zeile einen Hinweis bekommen hast. Das bedeutet, dass der Compiler einen Fehler gefunden hat (rot unterstrichen) und aber einen oder mehrere Lösungsvorschläge für dich hat (gelbe Glühbirne am Beginn der Zeile). Wenn du auf die Glühbirne klickst, bekommst du die Option angeboten, <strong>Add import org.bukkit.plugin.java.JavaPlugin</strong> und genau das wählst du aus. Damit sollte die Fehlermeldung verschwunden sein und ein paar Zeilen über der Zeile, die du gerade geschrieben hast, die Codezeile <code>import org.bukkit.plugin.java.JavaPlugin;</code> stehen.</p>

<p>Somit hätten wir ein fast lauffähiges Plugin, das genau gar nix macht. Da das genau niemand braucht, werden wir dem Ding mal sagen, dass es bei Aufruf <code>Hello stranger</code> ausgeben soll. Dazu müssen wir eine <em>Methode</em> anlegen und das geht so: Als erstes klickst du in die Klasse <code>FirstPlugin</code>, das heißt, du platzierst den Cursor in die Zeile zwischen der geschwungenen Klammer auf und wieder zu.</p>
<pre><code>public class FirstPlugin extends JavaPlugin {
   // your cursor must be here
}</code></pre>
<p>Also du klickst genau in die leere Zeile. Dann gehst du auf das Menü <strong>Source</strong> und wählst <strong>Insert Code&hellip;</strong> aus.</p>

<p><img src="02_first-plugin/AddOnCommandStep1.png" alt="Add onCommand" /></p>

<p>Damit bekommst du ein kleines Fensterchen, in welchem du <strong>Override Method&hellip;</strong> auswählst.</p>

<p><img src="02_first-plugin/AddOnCommandStep2.png" alt="Add onCommand" /></p>

<p>Und weils grad so lustig ist, kommt gleich noch ein Fenster, in welchem wir die Zeile mit <strong>onCommand(CommandSender sender, &hellip;)</strong> auswählen.</p>

<p><img src="02_first-plugin/AddOnCommandStep3.png" alt="Add onCommand" /></p>

<p>Wenn du dann auf <strong>Generate</strong> klickst, siehst du in deiner Klasse eine erste <em>Methode</em>. In einer Methode legst du fest, was das Plugin machen soll. Dazu löschst du als erstes die Zeile mit <code>return super.onCommand(sender, command, label, args)</code> und schreibst stattdessen folgendes rein:</p>
<pre><code>    sender.sendMessage(&#34;Hello stranger&#34;);
    return true;</code></pre>
<p>Am Ende sollte deine Klasse genau so aussehen:</p>

<p><img src="02_first-plugin/AddOnCommandStep4.png" alt="Add onCommand" /></p>

<p>Wenn du dich ein wenig umsiehst, wirst du merken, dass zum Import von <code>org.bukkit.plugin.java.JavaPlugin</code> noch ein paar weitere Imports dazugekommen sind und dann eben die <em>Methode</em> <code>onCommand</code>. Wenn du das noch nicht verstehst, mach dir keine Sorgen. Wir kommen darauf zurück.</p>

<p>Jetzt wollen wir aber so schnell wie möglich durch und unser Plugin zum Laufen bekommen. Was uns noch fehlt ist, dass wir für Minecraft erkenntlich machen, wie das Plugin heißt und auf welches Kommando es reagiert. Das machen wir im <code>plugin.yml</code>.</p>

<h3 id="das-plugin-yml-anlegen-das-projekt-bauen-und-testen">Das <code>plugin.yml</code> anlegen, das Projekt bauen und testen</h3>

<p>Im <code>plugin.yml</code> schreiben wir alles das rein, das Minecraft braucht, um unser Plugin zu erkennen und im richtigen Moment auch aufrufen zu können. Dazu legen wir das File zuerst einmal an. Überraschenderweise klickst du wieder mit der rechten Maustaste auf das <strong>Source Package</strong> und wählst <strong>New</strong> und <strong>YAML File&hellip;</strong> aus. Falls du diesen Eintrag nicht findest, wählst du im Menü ganz unten <strong>Other&hellip;</strong> aus und wählst aus der Kategorie <strong>Other</strong> den Punkt <strong>YAML File</strong> aus.</p>

<p><img src="02_first-plugin/AddYamlStep1.png" alt="Add onCommand" /></p>

<p>Inzwischen kennst du den zweiten Schritt wahrscheinlich auch schon: Wir müssen das File benennen. Achte darauf, dass,</p>

<ol>
<li>das File wirklich <code>plugin</code> heißt und</li>
<li>wie beim Java-File auch, du nicht die Dateierweiterung <code>.yml</code> dazuschreibst. Es reicht der Name <code>plugin</code>, im Feld <strong>Created File</strong> siehst du, dass das <code>yml</code> automatisch angehängt wird:</li>
</ol>

<p><img src="02_first-plugin/AddYamlStep2.png" alt="Add onCommand" /></p>

<p>Und wenn du jetzt in den Project Explorer schaust, dann entdeckst du, dass unser geliebtes <code>&lt;default package&gt;</code> wiederauferstanden ist. Das ist auch richtig so, da Minecraft das <code>plugin.yml</code> genau an dieser Stelle sucht.</p>

<p><img src="02_first-plugin/AddYamlStep3.png" alt="Add onCommand" /></p>

<p>Jetzt haben wir wieder ein leeres File und dürfen hier die notwendigen Informationen eintragen:</p>

<p><img src="02_first-plugin/AddYamlStep4.png" alt="Add onCommand" /></p>

<p>Bevor du beginnst, das abzuschreiben, lies dir die folgenden Punkte bitte durch: Als erstes achte bitte darauf, dass nach den Doppelpunkten immer unbedingt ein Leerzeichen kommen muss.</p>

<ol>
<li><strong>name</strong> ist eben der Name und kann beliebig gewählt werden. Sinnvollerweise nennen wir unser Plugin so, wie wir auch das Projekt genannt haben.</li>
<li>In <strong>main</strong> legen wir fest, in welcher Klasse das Plugin implementiert ist. Und zwar müssen wir das inklusive dem Package-Namen angeben. Vergleiche die Zeile mit <code>main</code> mit der Darstellung des Packages und der Klasse im Bild darüber. Du siehst, dass das übereinstimmt (bis auf <code>.java</code>).</li>
<li><strong>version</strong> ist eben die Verion. Das darfst du dir aussuchen.</li>
<li><strong>authors</strong> ist eine Liste der Authoren, die untereinander stehen und mit einem Minus (-) anfangen. Hier musst du darauf achten, dass die Zeilen mit den Listeneinträgen ein paar Leerzeichen (<strong>Achtung: keine Tabs</strong>) eingerückt sind.</li>
<li><strong>description</strong> beschreibt das Plugin. Hier kannst du deiner Fantasie wieder freien Lauf lassen.</li>
<li><strong>commands</strong> listet alle Kommandos, auf die das Plugin reagiert auf und gibt eine kurze Beschreibung und einen Benutzungshinweis an. Wir wollen, dass unser Plugin auf das Kommando <code>/sayhello</code> reagiert. Daher haben wir genau dieses Kommando angegeben. Auch hier achte wieder auf die Einrückungen. Diesmal sind es sogar zwei bei description und usage.</li>
</ol>

<p>Damit bist du jetzt wirklich fertig und kannst das gesamte Projekt bauen. Dazu klickst du auf den Hammer in der <strong>Toolbar</strong>:</p>

<p><img src="02_first-plugin/Toolbar.png" alt="Toolbar" /></p>

<p>Daraufhin sollte im <strong>Information Panel</strong> im Tab <strong>Output</strong> ca. folgende Information stehen:</p>

<p><img src="02_first-plugin/BuildOutput.png" alt="Output of the build run" /></p>

<p>Der wichtigste Punkt ist die letzte Zeile, in der auf jeden Fall <code>BUILD SUCCESSFULL</code> stehen muss. Damit ist nämlich klar, dass dein Projekt korrekt ist und vom Compiler übersetzt werden kann.</p>

<p>Um dein Plugin auszuprobieren musst du im File-Explorer (Windows) oder Finder (Mac) in dein NetBeans Projekt-Directory reinsehen. Dort sollte sich nun ein weiteres Directory <code>dist</code> befinden, in dem sich wiederum ein File <code>FirstPlugin.jar</code> befinden sollte. Dieses nimmst du nun und bewegst es in das Directory <code>plugins</code> des Server-Directories, das du noch aus unserer ersten Episode kennst.</p>

<p>Nun kannst du den Server starten. Als erstes überprüfen wir, ob das Plugin korrekt geladen wurde. Das sehen wir im Log des Servers, wenn er hochstartet:
<pre>
Loading libraries, please wait&hellip;
[20:49:34 INFO]: Starting minecraft server version 1.8.7
[20:49:34 INFO]: Loading properties
[20:49:34 INFO]: Default game type: SURVIVAL
[20:49:34 INFO]: This server is running CraftBukkit version git-Spigot-6d16e64-b105298 (MC: 1.8.7) (Implementing API version 1.8.7-R0.1-SNAPSHOT)
[20:49:34 INFO]: Debug logging is disabled
[20:49:34 INFO]: Server Ping Player Sample Count: 12
[20:49:34 INFO]: Using 4 threads for Netty based IO
[20:49:34 INFO]: Generating keypair
[20:49:34 INFO]: Starting Minecraft server on *:25565
[20:49:34 INFO]: Using default channel type
[20:49:34 INFO]: Set PluginClassLoader as parallel capable
[20:49:34 INFO]: [FirstPlugin] Loading FirstPlugin v0.1.0
&hellip;
</pre>
Innerhalb der ersten 15 bis 20 Zeilen solltest du die Zeile <code>[FirstPlugin] Loading FirstPlugin v0.1.0</code> sehen, dann wurde dein Plugin korrekt geladen. Lass dich nicht verwirren, da steht noch sehr viel mehr in der Console, also musst du ein Stück weit nach oben scrollen, damit du das siehst.</p>

<p>Abschließend kannst du testen, indem du das Kommando <code>sayhello</code> in der Konsole eingibst. Der Server sollte mit <code>Hello stranger</code> antworten. Auch kannst du noch ins Spiel gehen und dort den Befehl mit Slash <code>/sayhello</code> eingeben. Auch hier sollte der Server mit einem freundlichen <code>Hello stranger</code> antworten.</p>

<h3 id="eine-erweiterung">Eine Erweiterung</h3>

<p>Apropos freundlich. Jemanden mit &ldquo;Stranger&rdquo; zu begrüßen ist in Bezug auf Freundlichkeit sicherlich noch ausbaufähig. Da das Bukkit-API uns die Möglichkeit gibt, den Namen des Spielers (also den Minecraft-Namen natürlich) rauszufinden, werden wir das benutzen um den Spieler wirklich freundlich mit Namen zu begrüßen.</p>

<p>Dazu gehen wir wieder ins NetBeans und zur Methode <code>onCommand</code> unseres Plugins. Weil grad Zeit ist, sehen wir uns den Code der Methode ein wenig genauer an.</p>
<pre><code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    sender.sendMessage(&#34;Hello stranger&#34;);
    return true;
}</code></pre>
<p>Also der Reihe nach:</p>

<ul>
<li>In der ersten Zeile fällt in der Mitte eben der Name <code>onCommand</code> auf. <strong>Wir merken uns</strong>: Jede Methode hat einen Namen.</li>
<li>Nach dem Namen ist eine Klammer auf, die kurz vor Ende der Zeile auch wieder zu geht. <strong>Wir merken uns</strong>: Jede Methode hat gleich nach dem Namen eine Klammer auf und auch wieder eine Klammer zu.</li>
<li>Das zwischen diesen Klammern nennt man <em>Parameter</em>. Mit diesen kann man einer Methode Informationen geben, die sie für ihre Arbeit braucht. Du siehst bei der Methode <code>onCommand</code> oben, dass sie einen Parameter <code>sender</code> hat. Damit ist der &ldquo;Absender&rdquo; des Kommandos, also die Spielerin, die <code>/sayhello</code> eingetippt hat, gemeint.</li>
<li>Am Ende der Zeile ist eine geschwungene Klammer auf (<code>{</code>), die drei Zeilen später auch wieder geschlossen wird. Zwischen diesen Klammern steht drinnen, was die Methode jetzt wirklich macht. Das sind in unserem Fall zwei Dinge und da sehen wir uns grad mal die erste Zeile an: <code>sender.sendMessage(&quot;Hello stranger&quot;);</code>: Wir wissen schon von oben: <code>sender</code> ist der Absender des Kommandos. Nach dem Punkt kannst du alle die Methoden hinschreiben, die ein Sender &ldquo;versteht&rdquo;. <code>sendMessage</code> ist offensichtlich eine Methode, die einen Text ausgibt. Diese Methode hat ebenfalls einen Parameter, nämlich den Text, den wir gerne ausgegeben hätten.</li>
</ul>

<p>Gut, mit diesem Wissen können wir uns sammeln und kurz überlegen, was wir brauchen, damit wir den Sender mit seinem Minecraft-Namen begrüßen können.</p>

<ol>
<li>Wir brauchen eine Möglichkeit den Namen rauszufinden. Das geht mit der Methode <code>sender.getName()</code>. Du siehst, diese Methode braucht keine Parameter. Daher kommt nach der Klammer auf, sofort wieder eine Klammer zu.</li>
<li>Damit wären wir bei <code>sender.sendMessage(sender.getName())</code>. Aber was ist mit dem &ldquo;Hello&rdquo;, damit unsere Begrüßung auch wirklich freundlich wird?</li>
<li>Daher brauchen wir eine Möglickeit zwei Texte (also &ldquo;Hello&rdquo; und den Minecraft-Namen der Spielerin) zusammenzukleben. Das geht in Java mit dem Zeichen +. Also ergibt zum Beispiel <code>&quot;Ich &quot; + &quot;programmiere &quot; + &quot;Java&quot;</code> den Text <code>&quot;Ich programmiere Java&quot;</code>.</li>
<li>Also müssen wir die Zeile noch folgendermaßen erweitern: <code>sender.sendMessage(&quot;Hello &quot; + sender.getName());</code>.</li>
</ol>

<p>Zum Schluss sollte deine Methode so aussehen:</p>
<pre><code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    sender.sendMessage(&#34;Hello &#34; + sender.getName());
    return true;
}</code></pre>
<p>Nun sind wir schon wieder fertig. Wie oben musst du das Projekt wieder bauen (weißt schon, der Hammer in der Toolbar) und dann legst du am besten in deinem Verzeichnis <code>plugins</code> im Verzeichnis<code>bukkitServer</code> ein weiteres Verzeichnis mit Namen <code>update</code> an. Dorthinein kopierst du jetzt das jar-File. Abschließend gehst du in die Console, in der du den Server gestartet hast und tippst einfach <code>reload</code>. Dann sollte das Plugin neu geladen sein und du kannst es ausprobieren.</p>

<p>Zum Abschluss möchte ich dir noch eine Kleinigkeit zeigen: Es wird immer wieder notwendig sein, dass wir auf die Konsole des Servers etwas rausschreiben und daher wollen wir das gleich mal üben. Bisher kam die Antwort des Servers ja nur auf die Konsole, wenn du das Kommando direkt in der Konsole eingetippt hast. Wir wollen aber, dass, sobald irgendwer das Kommando <code>/sayhello</code> eintippt, in der Konsole vermerkt wird, dass dieses Kommando aufgerufen wurde.</p>

<p>Du kannst über <code>Bukkit.getLogger()</code> immer auf die Konsole zugreifen und der <code>Logger</code> hat eine Methode <code>info</code> mit der du Informationen in die Konsole schreiben kannst. Zusammengefasst sieht das ganze dann so aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        sender.sendMessage("Hello " + sender.getName());
        <b>Bukkit.getLogger().info("A player was greeted");</b>
        return true;
    }
</pre>

<p>Der Logger hat verschiedene <em>Levels</em>, die das Filtern des Logs erlauben. Die wichtigsten sind</p>

<ul>
<li><strong>Info</strong>: das sind einfache Informationen. Diese werden mit der Methode <code>info</code> ausgegeben.</li>
<li><strong>Warning</strong>: das sind Meldungen, die von einem Server-Administrator beachtet werden sollten. Diese werden mit der Methode <code>warning</code>ausgegeben.</li>
<li><strong>Severe</strong>: das sind kritische Meldungen, denen 100%ig auf den Grund gegangen werden muss. Diese werden mit der Methode <code>severe</code> ausgegeben.</li>
</ul>

<p>Da die Information, dass ein Spieler begrüßt wurde, nicht wirklich kritisch ist, belassen wir es bei einer einfachen Info-Message im Log.</p>

<h3 id="großeltern-imponier-wissen-1">Großeltern-Imponier-Wissen</h3>

<ul>
<li>Texte nennt man in der Informatik Zeichenketten oder auf Englisch: Strings</li>
<li>Ein <em>Log</em> ist so etwas wie ein Tagebuch. Vielleicht kennst du das aus Star Treck: &ldquo;Logbuch der Enterprise, Sternzeit &hellip;&rdquo;</li>
</ul>

<h3 id="zusammenfassung">Zusammenfassung</h3>

<p>Wenn du das Gefühl hast, dass das alles ganz schön viel ist und ein wenig verwirrend, dann lass dich nicht einschüchtern. Am Besten probierst du es gleich nochmal von vorne und legst nochmals ein neues Plugin-Projekt an. Am Anfang wirst du vielleicht noch öfter nachsehen müssen, dann reicht vielleicht eine Liste der Dinge, die gemacht werden müssen. So eine siehst du hier am Ende dieser Episode. Und nach einer Weile wird dir das ganz geläufig sein. Wie fast immer: Übung macht die Meisterin (und auch den Meister).</p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>Neues Projekt anlegen: Menüpunkt <strong>File</strong> &gt; <strong>New Project</strong>, in Choose Project: <strong>Java</strong> &gt; <strong>Java Class Library</strong> mit Projektnamen <code>FirstPlugin</code></li>
<li><code>craftbukkit.jar</code> zu den Libraries dazufügen: Rechte Maus-Klick auf <strong>Libraries</strong> &gt; <strong>Add JAR/Folder</strong></li>
<li>Package anlegen: Rechte Maus-Klick auf <strong>Source Packages</strong>, Auswahl von <strong>New</strong> &gt; <strong>Java Package</strong> mit Package Name z.B. <code>io.coderdojo.&lt;dein-name&gt;.firstplugin</code></li>
<li>Klasse anlegen: Rechte Maus-Klick auf das eben erstellte Package, Auswahl von <strong>New</strong> &gt; <strong>Java Class</strong> mit Class Name z.B. <code>FirstPlugin</code></li>
<li><code>extends JavaPlugin</code> nach dem Klassennamen dazuschreiben</li>
<li>Methode <code>onCommand</code> generieren: Rechte Maus-Klick im Editor zwischen den geschwungenen Klammern &gt; <strong>Inserter Code</strong> &gt; <strong>Override Method</strong> &gt; Auswahl von <code>onCommand</code> &gt; <strong>Generate</strong></li>
<li>Die Methode ausprogrammieren, also reinschreiben, was geschehen soll, wenn das Command aufgerufen wird:
<pre>
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    sender.sendMessage(&ldquo;Hello &rdquo; + sender.getName());
    Bukkit.getLogger().info(&ldquo;A player was greeted.&rdquo;);
    return true;
}
</pre></li>
<li><code>plugin.yml</code> zum Projekt hinzufügen: Rechte Maus-Klick auf <strong>Source Packages</strong> &gt; <strong>New</strong> auswählen &gt; <strong>YAML File</strong> mit File Name <code>plugin</code></li>

<li><p>Die Details im <code>plugin.yml</code> eingeben, wobei du die Details in den eckigen Klammern [] durch deine Werte ersetzt:
<pre></p>

<h2 id="yaml-template">YAML Template.</h2>

<hr />

<p>name: [Project Name]
main: [Package Name].[Class Name]
version: 1.0.0
author: [dein Name]
description: [deine Beschreibung des Plugins]
commands:
  [Command Name]:
    description: [deine Beschreibung des Kommandos]
    usage: /[Command Name]
</pre></p></li>

<li><p>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</p></li>

<li><p>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</p></li>

<li><p>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</p></li>

<li><p>Teste das Plugin indem du in Minecraft dein Kommando mit dem Namen, den du im <code>plugin.yml</code> unter <code>[Command Name]</code> vergeben hast, aufrufst.</p></li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/01_redstone-trap\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Die Redstone-Falle</h5>
                        <h6 class="card-subtitle mb-2 text-muted">Eine hinterhältige Falle für Zombies oder Mitspieler</h6>
                        <p class="card-text mt-4"><h1 id="eine-einfache-falle-mit-redstone">Eine einfache Falle mit Redstone</h1>

<p>In diesem Beispiel werden wir eine hinterhältige Falle bauen die Minecraft-Monster einfach zerquetscht.
Dazu müssen wir die Creeper und/oder Zombies einfach in einen Gang locken. Eignet sich auch zum <a href="https://www.zos-gaming.de/looten/" target="_blank">looten</a></p>

<h2 id="vorbereitung">Vorbereitung</h2>

<p>Was wir dafür benötigen ist in erster linie Cobblestone (Bruchstein), 2-3 Pistons (Kolben), einen Schalter, eine Pressure Plate (Druckplatte) und etwas Redstone.</p>

<p><img src="01_redstone-trap/01_inventory-begin.png" alt="Mindestbestand Inventar" /></p>

<h2 id="unterbau">Unterbau</h2>

<p>Damit wir die Pistons ordentlich platzieren können, heben wir eine 2 Block tiefe Grube und platzieren die Pistons. Anschließend noch Repeater an die Pistons anschließen (bitte auf die Richtung achten - müssen zum Piston hin zeigen). Dann noch alles mit Redstone verbinden und irgendwo weiter weg an die Oberfläche leiten. Am Eingang platzieren wir eine Pressure-Plate damit die Falle ausglöst werden kann.</p>

<p><img src="01_redstone-trap/02_build-1.png" alt="Rohbau der Falle" /></p>

<p>Danach können wir alles schön mit Cobblestone zumachen damit man nicht gleich sieht dass es eine Falle ist.</p>

<p><img src="01_redstone-trap/03_build-2.png" alt="Unterbau zumachen" /></p>

<p>Wenn der Gang mit der versteckten <em>&ldquo;Überraschung&rdquo;</em> dann fertig ist, sieht es ungefähr so aus:</p>

<p><img src="01_redstone-trap/04_trap_ready.png" alt="Fertiger Gang" /></p>

<p>Gut - die Falle selbst wäre jetzt fertig - unglücklicherweise kann man sie noch nicht auslösen. Das muss sich noch ändern.</p>

<h2 id="steuerung-der-falle">Steuerung der Falle</h2>

<p>Als ersten Versuch verbinden wir die Pressure-Plate einfach mittels Redstone-Leitung mit den Pistons. Damit wird die Falle sofort ausgelöst sobald irgendetwas die Platte betritt.</p>

<p><img src="01_redstone-trap/05_redstone_leitung_1.png" alt="Direkte Verbindung der Falle" /></p>

<p>Wie man auf dem Bild sieht bringt das leider noch nicht so viel, da die Falle zu schnell auslöst. Der Creeper hat sich lediglich etwas erschreckt &hellip;.</p>

<p>Besser wäre es die Falle ein wenig zu verzögern. Das geht mit Redstone-Repeatern:</p>

<p><img src="01_redstone-trap/06_redstone_leitung_2.png" alt="Direkte Verbindung der Falle" /></p>

<p><img src="attention_small.png" alt="Achtung" style="vertical-align: text-top; "/> die Repeater müssen in die richtige Richtung zeigen, sonst funktioniert es nicht.</p>

<p>Durch Rechtsklick auf die Repeater kann man eine Verzögerung in 3 Stufen einstellen. Damit hat der Creeper dann genug Zeit um in die Falle hineinzugehen, bevor sie zuschnappt. Probiert es einfach aus.</p></p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/09_teleporter\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Einfaches Teleporter Plugin</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Anleitung machst du ein einfaches Teleport-Plugin mit IntelliJ IDEA.</h6>
                        <p class="card-text mt-4">

<h1 id="minecraft-teleporter">Minecraft Teleporter</h1>

<p>Dieses plugin wurde mit der Entwicklungsumgebung <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ</a>
der Firma JetBrains geschrieben. <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ</a> unterstützt die
Entwicklung von Minecraft Plugins sehr gut.</p>

<h2 id="vorbereitungen">Vorbereitungen</h2>

<p>Zuerst ist es notwending die Entwicklungsumgebung <a href="https://www.jetbrains.com/idea/download" target="_blank">herunterzuladen</a> und zu installieren. Verwendet
hierfür die &ldquo;Community Edition&rdquo;. Wenn das geschehen ist, bitte das Modul für Minecraft hinzufügen.</p>

<p>Dafür bitte unter &ldquo;File&rdquo; -&gt; &ldquo;Settings&rdquo; die Einstellungen öffnen und danach &ldquo;Plugins&rdquo; klicken.</p>

<p><img src="09_teleporter/intellij_install_plugin1.PNG" alt="" /></p>

<p>Danach könnt ihr mit &ldquo;Browse repositories&rdquo; und dem Suchfeld nach &ldquo;Minecraft&rdquo; suchen.</p>

<p><img src="09_teleporter/intellij_install_plugin2.PNG" alt="" /></p>

<p>Ein Klick auf &ldquo;Install&rdquo; startet den Installationsvorgang (die Schaltfläche ist unter dem Titel und auf dem Bild leider nicht zu sehen).</p>

<h2 id="neues-projekt-anlegen">Neues Projekt anlegen</h2>

<p>Im Menü &ldquo;File&rdquo; -&gt; &ldquo;New&rdquo; könnt ihr nun ein neues Minecraft Projekt starten.</p>

<p><img src="09_teleporter/newproject2.png" alt="" /></p>

<p>Bitte hier den passenden Minecraft Server (Bukkit) anhaken und auf &ldquo;Next&rdquo; klicken.</p>

<p><img src="09_teleporter/newproject3.png" alt="" /></p>

<p>Wir verwenden zum bauen des Plugins das &ldquo;Gradle&rdquo; - System. Die Werte für GroupId und ArtifactId sind momentan beliebig.
Mit &ldquo;Next&rdquo; gehts weiter.</p>

<p>Anschließend geben wir dem Plugin noch einen Namen und eine Beschreibung. Main Class Name ist der Name der Java-Klasse in die wir die Funktionen unseres
Plugins coden werden.<br />
<img src="09_teleporter/newproject4.png" alt="" /></p>

<p>Danach erhält das Projekt noch einen Namen und wir legen fest, wo der Code gespeichert werden soll.
<img src="09_teleporter/newproject5.png" alt="" /></p>

<p>Mit einem kurzen Klick auf &ldquo;Finish&rdquo; wird unser Projekt angelegt. Bitte kurz Geduld. Der Vorgang kann schon mal 1-2 Minuten dauern.</p>

<h2 id="erstes-command">Erstes Command</h2>

<p>Wenn alle Schritte oben erfogreich waren, sollte euer Bildschirm nachher in etwa so aussehen:
<img src="09_teleporter/coding1.png" alt="" /></p>

<p>Die wichtisten Dateien am Anfang sind</p>

<ol>
<li><strong>plugin.yml</strong> - sie enthält die Beschreibung der Befehle die das Plugin können soll und</li>
<li><strong>Teleporter.java</strong> - Wird im IntellJ nur als &ldquo;Teleporter&rdquo; angezeigt. Sie enthält den Code für die Aktionen.</li>
</ol>

<p>Zuerst werden wir ein neues Kommando implementieren:
<img src="09_teleporter/coding2.png" alt="" /></p>

<p>Damit wird festegelegt dass dieses Kommando von unserem Plugin behandelt wird. Nun müssen wir noch dafür sorgen, dass es auch behandelt wird:
Dazu öffnen wir die Klasse Teleporter und fügen &ldquo;onCommand&rdquo; ein. (ein druck auf &lt;strng&gt; und die Leertaste machen das viel einfacher).</p>

<p><img src="09_teleporter/coding3.png" alt="" /></p>

<p>Danach sorgen wir dafür, dass auch etwas passiert, wenn jemand &ldquo;/sayhello&rdquo; in den Chat tippt.</p>

<p><img src="09_teleporter/coding4.png" alt="" /></p>

<p>das sieht dann in etwa so aus:</p>

<p><img src="09_teleporter/game1.png" alt="" /></p>

<p><strong>Kleine hilfe am Rande:</strong>  Damit ihr nicht jedes mal nach dem Bauen das Plugin in den Server hineinkopieren müsst, kann man mit folgendem kleinen
Zusatz im <em>build.gradle</em> das auch automatisch erledigen lassen.</p>

<p><img src="09_teleporter/gradle_deploy.PNG" alt="" /></p>

<h3 id="teleportieren">Teleportieren</h3>

<p>Um erfolgreich teleportiert werden zu können muss man vorher natürlich wissen wohin. Am Ende erscheint ihr noch in einer Wand oder in 10km Höhe.</p>

<p>Deswegen werden wir vorher einen Kommando definieren, bei dem man einen Ort markiert, an den Steve sich teleportieren soll.</p>

<p><strong>plugin.yml</strong></p>
<pre><code>name: Teleporter
version: @version@
main: at.coderdojo.teleporter.Teleporter
load: STARTUP
authors: [Minecraft, Mastercoders]
description: Beispielplugin zum Teleportieren
website: https://coderdojo-linz.github.io/
commands:
  sayhello:
    description: Says hello
    usage: /sayhello
  teleportziel:
    description: Ziel, an das wir uns teleportieren wollen.
    usage: /teleportziel
  teleportzu:
    description: Teleportiere zum vorher markierten Ziel.
    usage: /teleportzu</code></pre>
<p><em>teleportziel</em> soll das Ziel markieren, an das sich Steve teleportieren soll. z.B. kann er sich so jedesmal augenblicklich nach
Hause vor sein Bett teleportieren. Praktisch, wenn ihr euch schnell vor ein paar Zombies in Sicherheit bringen wollt tippt ihr danach
einfach <em>teleportzu</em>.</p>

<p>Nun fehlt uns nur noch der Code dazu im <em>Teleporter.java</em>.</p>

<p>Zuerst müssen wir die <code>onCommand</code> Funktion anpassen:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onCommand</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">,</span> Command command<span style="color:#f92672">,</span> String label<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//sender.sendMessage(&#34;Hallo &#34; + sender.getName());
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>command<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;sayhello&#34;</span><span style="color:#f92672">:</span>
                sender<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hallo &#34;</span> <span style="color:#f92672">+</span> sender<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;teleportziel&#34;</span><span style="color:#f92672">:</span>
                teleportZielMerken<span style="color:#f92672">(</span>sender<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;teleportzu&#34;</span><span style="color:#f92672">:</span>
                teleportZuZiel<span style="color:#f92672">(</span>sender<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
                sender<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Leider kann ich das Kommando &#34;</span> <span style="color:#f92672">+</span> command<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; noch nicht.&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span></code></pre></div>
<p>Damit kann <code>onCommand</code> zwischen den einzelnen Kommandos unterscheiden. Als nächstes brauche wir noch eine Möglichkeit die
gemerkten Position für jeden einzelnen Spieler zu merken.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teleporter</span> <span style="color:#66d9ef">extends</span> JavaPlugin <span style="color:#f92672">{</span>
    Dictionary<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Location<span style="color:#f92672">&gt;</span> teleportZiele <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Hashtable<span style="color:#f92672">&lt;&gt;();</span>

<span style="color:#f92672">....</span></code></pre></div>
<p>Die Funktion, sich den Punkt zu merken sieht dann in etwa so aus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">teleportZielMerken</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Player player <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Player<span style="color:#f92672">)</span> sender<span style="color:#f92672">;</span>
        teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">(),</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getLocation</span><span style="color:#f92672">());</span>
        player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Ok, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, ich habe mir das gemerkt&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span></code></pre></div>
<p>und die Funktion die Steve zu dem Ort zurückbringen soll in etwa so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">teleportZuZiel</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Player player <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Player<span style="color:#f92672">)</span> sender<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hey, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;. Du musst dir zuerst einen Punkt merken&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        player<span style="color:#f92672">.</span><span style="color:#a6e22e">teleport</span><span style="color:#f92672">(</span>teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()));</span>
        player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Ok, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, hab dich dorthin geschickt&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span></code></pre></div>
<p><strong>Info:</strong> das <code>if (teleportZiele.get(player.getName()) == null)</code> dient dazu, zuerst festzustellen ob wir uns schon eine
Position für diesen Spieler gemerkt haben. Ansonst würde das <code>player.teleport</code> einen Fehler verursachen.</p>

<p>Das gesamte <code>Teleporter.java</code> sieht nach den Änderungen so aus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> at.coderdojo.teleporter<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> org.bukkit.Location<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.bukkit.command.Command<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.bukkit.command.CommandSender<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.bukkit.entity.Player<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.bukkit.plugin.java.JavaPlugin<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> java.util.Dictionary<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> java.util.Hashtable<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teleporter</span> <span style="color:#66d9ef">extends</span> JavaPlugin <span style="color:#f92672">{</span>
    Dictionary<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Location<span style="color:#f92672">&gt;</span> teleportZiele <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Hashtable<span style="color:#f92672">&lt;&gt;();</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onEnable</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Plugin startup logic
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onDisable</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Plugin shutdown logic
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onCommand</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">,</span> Command command<span style="color:#f92672">,</span> String label<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//sender.sendMessage(&#34;Hallo &#34; + sender.getName());
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>command<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;sayhello&#34;</span><span style="color:#f92672">:</span>
                sender<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hallo &#34;</span> <span style="color:#f92672">+</span> sender<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;teleportziel&#34;</span><span style="color:#f92672">:</span>
                teleportZielMerken<span style="color:#f92672">(</span>sender<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;teleportzu&#34;</span><span style="color:#f92672">:</span>
                teleportZuZiel<span style="color:#f92672">(</span>sender<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
                sender<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Leider kann ich das Kommando &#34;</span> <span style="color:#f92672">+</span> command<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; noch nicht.&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">teleportZielMerken</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Player player <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Player<span style="color:#f92672">)</span> sender<span style="color:#f92672">;</span>
        teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">(),</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getLocation</span><span style="color:#f92672">());</span>
        player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Ok, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, ich habe mir das gemerkt&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">teleportZuZiel</span><span style="color:#f92672">(</span>CommandSender sender<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Player player <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Player<span style="color:#f92672">)</span> sender<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hey, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;. Du musst dir zuerst einen Punkt merken&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        player<span style="color:#f92672">.</span><span style="color:#a6e22e">teleport</span><span style="color:#f92672">(</span>teleportZiele<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()));</span>
        player<span style="color:#f92672">.</span><span style="color:#a6e22e">sendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Ok, &#34;</span> <span style="color:#f92672">+</span> player<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, hab dich dorthin geschickt&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div></p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/erste-schritte-mit-redstone\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Erste Schritte mit Redstone</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Übung lernst du Redstone in Minecraft kennen</h6>
                        <p class="card-text mt-4">

<h1 id="erste-schritte-mit-redstone">Erste Schritte mit Redstone</h1>

<h2 id="voraussetzung">Voraussetzung</h2>

<p>Für diese Übung brauchst du <a href="https://minecraft.net/de-de/" target="_blank">Minecraft</a>. Du solltest mit den Grundfunktionen wie Steuerung des Spielers, verwenden von grundlegenden Blöcken etc. vertraut sein.</p>

<h2 id="was-ist-redstone">Was ist <em>Redstone</em>?</h2>

<p><img src="erste-schritte-mit-redstone/redstone.png" alt="Redstone" /><br/>
<a href="http://minecraft-de.gamepedia.com/Redstone" target="_blank">Redstone</a> ist ein wichtiger Rohstoff in Minecraft. Wie in der echten Welt mit Strom kannst du mit Redstone in Minecraft Schaltkreise (Englisch <em>Ciruits</em>) bauen. Egal ob Falle für Monster, Lichtsteuerung oder automatische Türen - für all das verwendest du Redstone.</p>

<p><strong>Hinweis für Eltern:</strong> Schaltungen mit Redstone sind ein gutes Beispiel dafür, warum Minecraft viel mehr ist als nur ein Unterhaltungsspiel. Kreativität und logisches Denken sind gefragt, wenn man mit Redstone arbeiten möchte.</p>

<h2 id="spiel-zum-experimentieren-vorbereiten">Spiel zum Experimentieren vorbereiten</h2>

<p>Um Redstone kennenzulernen, startest du am besten eine flache Welt im Kreativmodus.</p>

<p><img src="erste-schritte-mit-redstone/kreativmodus.png" alt="Kreativmodus" /></p>

<p><img src="erste-schritte-mit-redstone/flachland.png" alt="Kreativmodus" /></p>

<h2 id="redstone-im-inventar">Redstone im Inventar</h2>

<p>Die Gegenstände, die mit Redstone zu tun haben, findest du im Inventar:</p>

<p><img src="erste-schritte-mit-redstone/redstone-inventar.png" alt="Redstone im Inventar" /></p>

<h2 id="dein-erster-schaltkreis">Dein erster Schaltkreis</h2>

<p><img src="erste-schritte-mit-redstone/erste-schaltung.png" alt="Erste Schaltung" /></p>

<ol>
<li><p>Setze einen <a href="http://minecraft-de.gamepedia.com/Redstone-Block" target="_blank">Redstone-Block</a>. Er ist die <strong>Energiequelle</strong> für deine Schaltung.</p></li>

<li><p>Ein paar Felder daneben setzt du eine <a href="http://minecraft-de.gamepedia.com/Redstone-Lampe" target="_blank">Redstone-Lampe</a>. Sie <strong>leuchtet</strong>, wenn sie mit Energie versorgt wird.</p></li>

<li><p>Anschließend verbinde die beiden Blöcke mit <a href="http://minecraft-de.gamepedia.com/Redstone" target="_blank">Redstone</a>. Jetzt fließt Energie und die Lampe leuchtet.</p></li>
</ol>

<h2 id="schalter">Schalter</h2>

<p><img src="erste-schritte-mit-redstone/schalter.png" alt="Erste Schaltung" /></p>

<ol>
<li><p>Ersetze den Redstone-Block durch einen normalen Block. Ich verwende hier <strong>blaue <a href="http://minecraft-de.gamepedia.com/Wolle" target="_blank">Wolle</a></strong>. <strong>Tipp:</strong> Es ist üblich, dass Schaltkreise auf eingefärbter Wolle gelegt werden. Dadurch erkennt man leichter, wie eine Schaltung funktioniert.</p></li>

<li><p>Bringe einen <strong><a href="http://minecraft-de.gamepedia.com/Schalter_(Begriffskl%C3%A4rung)" target="_blank">Schalter</a></strong> an dem normalen Block an. Er ist eine <strong>Energiequelle</strong>, die du ein- und ausschalten kannst.</p></li>

<li><p>Schalte jetzt die Redstone-Lampe ein und wieder aus.</p></li>

<li><p>Ersetze den Schalter durch einen <strong>Knopf</strong> und beobachte, wie er nach dem Drücken einen kurzen Energieimpuls abgibt.</p></li>
</ol>

<h2 id="kolben">Kolben</h2>

<p><img src="erste-schritte-mit-redstone/kolben.png" alt="Erste Schaltung" /></p>

<ol>
<li><p>Setze einen <strong>klebrigen <a href="http://minecraft-de.gamepedia.com/Kolben" target="_blank">Kolben</a></strong>. <strong>Tipp:</strong> Wenn der Kolben nach oben ausfahren soll, muss du in den Flugmodus wechseln (2 x schnell hintereinander die Leertaste drücken) und ihn von oben setzen.</p></li>

<li><p>Setze einen beliebigen Block auf den Kolben. Ich verwende einen Gold-Block.</p></li>

<li><p>Füge zu deiner Schaltung eine Abzweigung hinzu. Verbinde sie mit dem Kolben.</p></li>

<li><p>Betätige den Schalter und beachte, wie Licht und Kolben sich gleichzeitig verändern.</p></li>
</ol>

<h2 id="fackel">Fackel</h2>

<h3 id="fackel-als-energiequelle">Fackel als Energiequelle</h3>

<p><img src="erste-schritte-mit-redstone/fackel.png" alt="Redstone Fackel" /></p>

<ol>
<li><p>Setze eine <a href="http://minecraft-de.gamepedia.com/Redstone-Fackel" target="_blank">Redstone-Fackel</a> wie oben gezeigt. Die Fackel ist eine <strong>Energiequelle</strong>.</p></li>

<li><p>Achte im Beispiel oben darauf, wie Redstone über Stufen nach oben fließen kann. Dadurch fängt die Lampe zu Leuchten an.</p></li>
</ol>

<h3 id="fackel-ein-und-ausschalten">Fackel ein- und ausschalten</h3>

<p><img src="erste-schritte-mit-redstone/fackel-ein-aus.png" alt="Redstone Fackel" /></p>

<p>Fackeln gehen aus wenn sie mit Energie versorgt werden. Sie drehen ein Energiesignal also um (aus <em>an</em> wird <em>aus</em> und umgekehrt).</p>

<h2 id="übungsaufgabe">Übungsaufgabe</h2>

<p>Baue ein Haus mit Licht an der Decke. Es soll innen einen Schalter haben, mit dem du es ein- und ausschalten kannst. Verkleide anschließend dein Haus damit man von außen die Redstone-Schaltung nicht sieht.</p>

<p><strong>Tipp 1</strong>: Lass die Energie mit Redstone über eine Treppe nach oben fließen:</p>

<p><img src="erste-schritte-mit-redstone/haus-mit-licht-schalter.png" alt="Erste Schaltung" /></p>

<p><strong>Tipp 2</strong>: Redstone überträgt Energie maximal 15 Blöcke weit. Die Energiestärke nimmt dabei ab. Um das Signal nach einer langen Leitung zu verstärken, setze einen <strong><a href="http://minecraft-de.gamepedia.com/Redstone-Verst%C3%A4rker" target="_blank">Verstärker</a></strong> ein.</p>

<p><img src="erste-schritte-mit-redstone/haus-mit-licht-dach.png" alt="Erste Schaltung" /></p>

<p><strong>Tipp 3</strong>: Um dein Licht auszuprobieren, kannst du mit dem Befehl <code>/time set night</code> auf Nacht umschalten. Mit <code>/time set day</code> kommst du wieder in den Tag.</p>

<h2 id="wie-geht-es-weiter">Wie geht es weiter?</h2>

<p>Im CoderDojo Linz haben wir das <em>Schaltkreis-Handbuch für Minecraft</em>. Lies dort mehr über Redstone und baue die im Buch gezeigten Schaltungen nach.</p>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/04_getafix-arguments\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Getafix Arguments</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Episode wirst du andere heilen lernen</h6>
                        <p class="card-text mt-4">

<h1 id="miraculix-der-druide-teil-2">Miraculix der Druide – Teil 2</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#long">Ausführliche Anleitung</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
<li><a href="#ideas">Ideen für weitere Entwicklungen</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>In der letzten Episode haben wir begonnen, ein Plugin für die Befehle <code>gethealth</code> und <code>heal</code> zu implementieren. Ich habe dir ja versprochen, dass wir am Ende nicht nur uns selbst, sondern auch andere Spieler auf dem Server heilen werden können. Also sollen die folgenden Befehle nun wirklich funktionieren:</p>
<pre><code>/gethealth me
/gethealth OidaZocktYT
/heal me
/heal OidaZocktYT</code></pre>
<p><img src="04_getafix-Arguments/Command.png" alt="How the command looks like" /></p>

<h2 id="a-name-long-a-ausführliche-anleitung"><a name="long"></a>Ausführliche Anleitung</h2>

<h3 id="am-anfang-ein-wenig-zusammenräumen">Am Anfang ein wenig Zusammenräumen</h3>

<p>Ich habe dir ja in der letzten Episode die Lösung für das <code>/heal</code> Kommando versprochen. Also am Ende sollte deine Methode <code>onCommand</code> so aussehen:
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (label.equalsIgnoreCase(&ldquo;gethealth&rdquo;)) {    // get health
            if (sender instanceof Player) {
                Player player = (Player) sender;
                sender.sendMessage(&ldquo;Health of &rdquo; + player.getName() + &ldquo;: &ldquo; + player.getHealth());
                return true;
            } else {
                sender.sendMessage(&ldquo;This command can only be used by players&rdquo;);
                return false;
            }
        } else // heal
        if (sender instanceof Player) {
            Player player = (Player) sender;
            player.setHealth(20.);
            player.sendMessage(&ldquo;Successfully healed player &rdquo; + player.getName() + &ldquo;.&rdquo;);
            Bukkit.getLogger().info(&ldquo;The player &rdquo; + player.getName() + &ldquo; was successfully healed.&rdquo;);
            return true;
        } else {
            sender.sendMessage(&ldquo;This command can only be used by players&rdquo;);
            return false;
        }
    }
</pre>
Ich weiß ja nicht, wie es dir geht, aber das fängt an, wie ein richtiges Programm auszusehen. Leider muss man auch anmerken, dass es auch schon anfängt, ein wenig unübersichtlich zu werden.</p>

<p>Bevor das mit dem Einbau neuer Features wirklich in Chaos ausartet, wollen wir gleich ein bisschen zusammenräumen.</p>

<p>Du siehst ja sicherlich, dass sich die ganze Methode in zwei große Blöcke unterteilt</p>

<ol>
<li>Die Behandlung von <code>/gethealth</code></li>
<li>Die Behandlung von <code>/heal</code></li>
</ol>

<p>Damit du es gut erkennst habe ich die beiden Blöcke fett eingezeichnet. Nun ist es aber so, dass die beiden Blöcke selbst wieder sehr ähnlich sind. Sie überprüfen beide, ob <code>sender</code> eh ein <code>Player</code> ist und machen dann das Gewünschte oder geben eine Fehlermeldung aus. Da könnten wir doch die Überprüfung, ob <code>sender</code> ein <code>Player</code> ist gleich am Anfang der Methode genau einmal machen und dann erst das Kommando ausführen.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
        
        Player player = (Player) sender;
        
        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        } else {
            player.setHealth(20.);
            return true;
        }
    }
</pre>

<p>Ok, da hat sich jetzt einiges getan, das wir uns näher ansehen müssen: Zu Beginn haben wir das <code>if</code> mit der eh schon bekannten Bedingung, doch halt! Siehst du das <code>!</code> vor der Bedingung? Das bedeutet <em>Nicht</em>. Das heißt jetzt, wenn <code>sender</code> <em>nicht</em> ein <code>Player</code> (also wenn <code>sender</code> <em>kein</em>  <code>Player</code>) ist, dann geben wir eine Fehlermeldung aus. Und dann kommt da das <code>return false</code>. Das wollen wir uns auch gleich mal ansehen:</p>

<p>Zum einen will ich dir erklären, was das Wort <code>return</code> zu bedeuten hat. Wie du ja sicherlich schon bemerkt hast, werden Programme Anweisung für Anweisung, von oben nach unten, ausgeführt. Wenn ein <code>if</code> kommt entscheidet es sich, wo es weitergeht (je nachdem, wie die Bedingung in der Klammer nach dem <code>if</code> ausgeht), aber sonst gehts recht einfallslos dahin. Wenn aber ein <code>return</code> auftaucht, dann kommt wieder Leben in die Sache, weil da wird die laufende Methode <em>sofort</em> verlassen.</p>

<p>Gut wirst du sagen, das ist ja alles recht gut und schön, aber warum steht da noch dieses <code>false</code> dabei? Dazu wollen wir uns nochmals die allererste Zeile von <code>onCommand</code> ansehen:</p>
<pre><code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {</code></pre>
<p>Den hinteren Teil ab <code>onCommand</code> haben wir uns ja schon letztes Mal angesehen (du weißt schon: <code>onCommand</code> ist der Name, dann kommen die Parameter). Heute wollen wir uns die ersten beiden Wörter ansehen:</p>

<ol>
<li><code>public</code> heißt, dass die Methode von außen aufgerufen wird. Stell dir das so vor, dass der Spieler die Methode <code>onCommand</code> durch das Eintippen des Kommandos <code>/gethealth</code> oder <code>/heal</code> aufruft. Das passiert aber außerhalb dieser Klasse. Wenn wir dann gegen Ende dieser Episode neue Methoden hinzufügen, dann werden die <code>private</code> sein weil sie nur von <code>onCommand</code> aber nicht von irgendwo außerhalb dieser Klasse aufgerufen werden.</li>
<li><code>boolean</code> heißt, dass beim Verlassen der Methode ein Wert des Datentyps <code>boolean</code> (das ist entweder <code>true</code> oder <code>false</code>, ja genau so wie bei der Bedingung in einer <code>if</code>-Bedingung) zurückgegeben wird.</li>
</ol>

<p>Also heißt das, dass <code>onCommand</code> nicht einfach so verlassen werden kann, sondern, dass ein boolescher Wert angegeben werden muss. Deswegen steht hier auch noch das <code>false</code>. Wir könnten auch <code>true</code> zurückgeben, aber es gibt die Konvention, dass <code>onCommand</code> den Wert <code>true</code> genau dann zurückgibt, wenn es das Kommando <em>erfolgreich</em> ausführen konnte. Das ist aber hier nicht der Fall, deswegen <code>false</code>.</p>

<p>Damit haben wir nach diesem <code>if</code>-Block freie Bahn, den <code>sender</code> auf <code>Player</code> zu casten und, je nach eingegebenen Kommando das Richtige zu tun. Eines fällt uns noch auf: Sowohl im <code>if (label.equalsIgnoreCase(...))</code> als auch im <code>else</code> steht ein <code>return true</code>. Das können wir auch rausnehmen und einmal am Ende der Methode hinschreiben. Damit wird die Sache nochmals ein bisschen einfacher.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
        
        Player player = (Player) sender;
        
        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<h3 id="argumente-eines-kommandos">Argumente eines Kommandos</h3>

<p>Bisher haben wir ja das zweite Wort unseres Kommandos völlig ignoriert. Streng genommen werden Kommandos in das eigentliche <em>Kommando</em> (in unserem Fall <code>/gethealth</code> oder <code>/heal</code>) und in weitere <em>Argumente</em> (<code>me</code> oder <code>OidaZocktYT</code> oder einen anderen Spielernamen) aufgeteilt.</p>

<p>Da stellt sich als erstes natürlich die Frage, wie wir zu diesem Argument dazukommen. Wenn du dir die Parameter der Methode <code>onCommand</code> ansiehst, siehst du zum Schluss einen namens <code>args</code>. Der Datentyp von <code>args</code> ist <code>String[]</code>. Hmh, <code>String</code> kennen wir ja schon aber was ist <code>String[]</code>? Überlegen wir mal: wir könnten ja auch einmal ein Kommando <code>/heal me 3</code> schreiben wollen, damit wir die Gesundheit um 3 Punkte erhöhen können. Dieses Kommando hätte dann 2 Argumente, nämlich <code>me</code> und dann <code>3</code>. Das heißt, dass wir 0, 1, 2, &hellip; Argumente haben könnten. Damit ist ein <code>String</code> nicht ausreichend, wir brauchen eine Reihe von Stirngs, je nachdem, wieviele Argumente der Benutzer eingetippt hat. Hier kommt dann <code>String[]</code> ins Spiel. Das ist eine Reihe von Strings (Informatiker nennen das ein <em>Array von Strings</em>), einer für jedes Argument.</p>

<p>Jetzt wollen wir sehen, wie wir auf diese einzelnen Teile dieses Arrays zugreifen können und wie wir sehen, wie viele solcher Teile in diesem Array drinnen sind. Dazu erweitern wir unser <code>onCommand</code> folgendermaßen:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>sender.sendMessage("There were " + args.length + " arguments given.");
        sender.sendMessage("The first is " + args[0]);</b>
       
        if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
        
        Player player = (Player) sender;
        
        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Du siehst, dass wir <code>args.length</code> verwenden, um die Anzahl der Elemente in <code>args</code> rauszufinden. In der zweiten Zeile siehst du, dass wir auf das erste Element mit <code>args[0]</code> zugreifen. Das zweite Element wäre dann <code>args[1]</code> usw.</p>

<p>Baue das Projekt und probier es aus, ob es auch wirklich funktioniert. Wenn es passt, dann spiel ein wenig rum und gib auch das zweite und dritte Argument aus. Was passiert, wenn du weniger Argumente eingibst, als du dann in <code>onCommand</code> ausliest?</p>

<h3 id="einige-überlegungen">Einige Überlegungen</h3>

<p>Was brauchen wir jetzt? Wenn der Spieler das Argument <code>me</code> eingibt, dann ist das ja sehr einfach, weil wir genau unsere bisherige Methode aufrufen können, damit wir unseren eigenen Health-level ausgeben oder uns selbst heilen können.</p>

<p>Anders ist es, wenn der Spieler einen Spielernamen eingibt. Hier können wir den <code>Player</code> nicht einfach durch einen Cast vom <code>sender</code> erzeugen. Wir müssen uns aufgrund des Spielernamens den <code>Player</code> holen.</p>

<p>Wenn wir den Player dann haben, kann der Rest der Methode wie gehabt ablaufen.</p>

<h3 id="endlich-das-neue-feature">Endlich das neue Feature</h3>

<p>Fangen wir gleich mit dem Code an, die Erklärung gibts nachher.</p>

<pre>
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
<b>
        String playerName = args[0];    // first argument is player name
        Player player;

        if (playerName.equalsIgnoreCase("me")) {
            player = (Player) sender;
        } else {
            player = Bukkit.getPlayer(playerName);
        }
</b>
        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Du siehst, wir haben nur den mittleren Teil verändert (der fett gedruckte Teil).  Hier speichern wir uns zuerst den Spielernamen in eine eigene Variable, damit das ganze einfacher lesbar wird.</p>

<p>Dann kommt der Teil mit dem Rausfinden des Spielers. Zuerst deklarieren wir nur eine Variable <code>player</code>, ohne ihr sofort einen Wert zuzuweisen und dann kommt das <code>if</code>: Wenn der <code>playerName</code> den Wert <code>me</code> hat, dann machen wir, wie oben überlegt, den üblichen cast. Wenn <code>playerName</code> aber einen anderen Wert hat, dann holen wir uns den <code>Player</code>. Dafür gibt es von <code>Bukkit</code> eine eigene Methode <code>getPlayer</code>. Cool, nicht?</p>

<p>Damit geht es wieder ans Bauen und Probieren. Sinnvollerweise änderst du die Versionsnummer im <code>plugin.yml</code> auf <code>0.3.0</code>. Zum Testen ist es wichtig, dass eine Freundin oder Freund mit dir auf dem gleichen Server spielt, sonst kannst du ja keinen Namen für <code>/heal</code> oder <code>gethealth</code> angeben. Was passiert eigentlich, wenn du einen Namen eingibst, der nicht auf dem Server spielt?</p>

<h3 id="ein-paar-notwendige-erweiterungen">Ein paar notwendige Erweiterungen</h3>

<p>Und wie sind deine Tests verlaufen? Also mir sind folgende Dinge aufgefallen.</p>

<ol>
<li>Wenn ich vergesse einen Namen oder auch <code>me</code> einzugeben, kommt wieder eine Exception. Das kommt daher, weil wir auf ein Element des Arrays <code>args</code> zugreifen wollen, das es gar nicht gibt.</li>
<li>Wenn ich einen Namen eingebe, der grad nicht auf meinem Server Spielt, bekomme ich auch eine Exception. Das kommt daher, dass <code>player</code> dann keinen gültigen Wert haben kann (woher auch, wenns den Spieler auf dem Server gar nicht gibt) und damit die Methoden <code>player.sendMessage</code> und <code>player.setHealth</code> nicht ausgeführt werden können.</li>
</ol>

<p>Das müssen wir unbedingt beheben, weil so einen Mist werden wir sicherlich nicht ausliefern.</p>

<p>Um den Fehler Nummer 1 in den Griff zu bekommen brauchen wir eigentlich nur am Beginn der Methode, nachdem wir den <code>sender</code> überprüft haben, die Anzahl der Argumente überprüfen. Wenn die Anzahl nicht 1 ist, dann geben wir einfach <code>false</code> zurück. Wie du vielleicht schon bemerkt hast, gibt der Server dann automatisch die <code>usage</code>-Meldung aus dem <code>plugin.yml</code> aus und das ist genau die richtige Reaktion.</p>

<p>Um den Fehler Nummer 2 zu beheben, müssen wir wissen, dass <code>Bukkit.getPlayer</code> den Wert <code>null</code> zurückgibt, falls der Player auf dem Server nicht gefunden werden kann. Damit können wir nachdem wir den <code>Player</code> ermittelt haben, überprüfen ob dieser <code>null</code> ist. Wenn das so ist, geben wir wieder eine Fehlermeldung aus und verabschieden uns aus der Methode.
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage(&ldquo;Command can only be used by player&rdquo;);
            return false;
        }</p>
<pre><code>    &lt;b&gt;if (args.length != 1) {
        return false;
    }&lt;/b&gt;

    String playerName = args[0];    // first argument is player name
    Player player;

    if (playerName.equalsIgnoreCase(&#34;me&#34;)) {
        player = (Player) sender;
    } else {
        player = Bukkit.getPlayer(playerName);
    }

    &lt;b&gt;if (player == null) {
        sender.sendMessage(&#34;Player &#34; + playerName + &#34; is not online&#34;);
    }&lt;/b&gt;

    if (label.equalsIgnoreCase(&#34;gethealth&#34;)) {
        player.sendMessage(&#34;Health of &#34; + player.getName() + &#34;: &#34; + player.getHealth());
        return true;
    } else {
        player.setHealth(20.);
    }
    return true;
}</code></pre>
<p></pre>
So, jetzt kannst du das ganze nochmals bauen und ausführlich testen.</p>

<h3 id="und-wieder-ein-wenig-zusammenräumen">Und wieder ein wenig zusammenräumen</h3>

<p>Und, waren die Tests jetzt erfolgreich? Bei mir ist nix besonderes mehr aufgetaucht. Damit kannst du die Versionsnummer im <code>plugin.yml</code> auf 0.3.1 stellen. Du siehst aber, dass die Methode schon ganz schön länglich wird. Sie ist zwar nicht mehr so verschachtelt, wie sie am Anfang unserer Episode war aber mit dem neuen Feature hat sich die Länge einfach verdoppelt. Das wollen wir noch beheben, bevor wir noch eine letzte kleine Verbesserung einbauen.</p>

<p>Der Startpunkt für unser Zusammenräumen ist, dass sich die Methode in vier Teile teilt</p>

<ol>
<li>Wir überprüfen, ob alles richtig ist, dass wir das Kommando ausführen können</li>
<li>Wir holen uns den Player aufgrund des angegebenen Namens</li>
<li>Wir überprüfen, ob der Player online ist</li>
<li>Wir führen das Kommando aus</li>
</ol>

<p>Und genauso wollen wir unsere Methode jetzt strukturieren. Im folgenden Code siehst du die Überprüfung, ob das Kommando ausgeführt werden kann, fett dargestellt:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
        
        if (args.length != 1) {
            return false;
        }</b>
       
        String playerName = args[0];    // first argument is player name
        Player player;

        if (playerName.equalsIgnoreCase("me")) {
            player = (Player) sender;
        } else {
            player = Bukkit.getPlayer(playerName);
        }
        
        if (player == null) {
            sender.sendMessage("Player " + playerName + " is not online");
        }

        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Wenn du jetzt mit der Maus genau diesen fett eingezeichneten Block auswählst (mit gedrückter Maustaste vom <code>if</code> bis zur geschlossenen <code>}</code> fahren) und dann im Menü <strong>Refactor</strong> unter <strong>Introduce</strong> den Punkt <strong>Method&hellip;</strong> auswählst, dann heißt das, dass wir eine neue Methode einführen, welche genau diesen Code-Teil behandelt.</p>

<p><img src="04_getafix-Arguments/ExtractMethodStep1.png" alt="Choose extract method in menu Refactor" /></p>

<p>Nachdem du den Menüpunkt ausgewählt hast, bekommst du folgendes Bild</p>

<p><img src="04_getafix-Arguments/ExtractMethodStep2.png" alt="Name extracted method" /></p>

<p>Wir benennen die neue Methode <code>argumentCannotBeHandled</code>, da wir in dem Code ja die beiden Situationen rausfiltern, wo wir das Kommando nicht sinnvoll ausführen können. Weiters legen wir fest, dass ihr <strong>Access private</strong> sein soll, weil sie eben nur aus <code>onCommand</code> aufgerufen wird und nicht von irgendwo außerhalb der Klasse (beispielsweise vom Spieler). Wenn du jetzt <strong>Ok</strong> klickst, dann sollte dein Code folgendermaßen aussehen.
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (commandCannotBeHandled(sender, args)) return false;</b></p>
<pre><code>    String playerName = args[0];    // first argument is player name
    Player player;

    if (playerName.equalsIgnoreCase(&#34;me&#34;)) {
        player = (Player) sender;
    } else {
        player = Bukkit.getPlayer(playerName);
    }

    if (player == null) {
        sender.sendMessage(&#34;Player &#34; + playerName + &#34; is not online&#34;);
    }

    if (label.equalsIgnoreCase(&#34;gethealth&#34;)) {
        player.sendMessage(&#34;Health of &#34; + player.getName() + &#34;: &#34; + player.getHealth());
        return true;
    } else {
        player.setHealth(20.);
    }
    return true;
}</code></pre>
<p><b>
    private boolean commandCannotBeHandled(CommandSender sender, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage(&ldquo;Command can only be used by player&rdquo;);
            return true;
        }
        if (args.length != 1) {
            return true;
        }
        return false;
    }</b>
</pre>
Du siehst, dass der ganze Block, den du ausgewählt hast, in eine neue Methode gewandert ist und dass der <code>if</code>-Teil von <code>onCommand</code> nur mehr eine Zeile lang ist.</p>

<p>Dann holen wir uns den zweiten großen Block:
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;</p>
<pre><code>    String playerName = args[0];    // first argument is player name
    &lt;b&gt;Player player;

    if (playerName.equalsIgnoreCase(&#34;me&#34;)) {
        player = (Player) sender;
    } else {
        player = Bukkit.getPlayer(playerName);
    }&lt;/b&gt;

    if (player == null) {
        sender.sendMessage(&#34;Player &#34; + playerName + &#34; is not online&#34;);
    }

    if (label.equalsIgnoreCase(&#34;gethealth&#34;)) {
        player.sendMessage(&#34;Health of &#34; + player.getName() + &#34;: &#34; + player.getHealth());
        return true;
    } else {
        player.setHealth(20.);
    }
    return true;
}</code></pre>
<p></pre></p>

<p>Wir wählen ihn wieder aus, <strong>Introduce Method&hellip;</strong>, benennen sie <code>getPlayer</code>, <strong>Access Private</strong> und los gehts. Ich zeige dir hier nur mehr die Methode <code>onCommand</code>:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;

        String playerName = args[0];    // first argument is player name
        <b>Player player = getPlayer(playerName, sender);</b>

        if (player == null) {
            sender.sendMessage("Player " + playerName + " is not online");
            return false;
        }

        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Nun der dritte Block:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;

        String playerName = args[0];    // first argument is player name
        Player player = getPlayer(playerName, sender);
        <b>
        if (player == null) {
            sender.sendMessage("Player " + playerName + " is not online");
            return false;
        }</b>

        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Da wir bei <code>Bukkit.getPlayer</code> dann <code>null</code> zurückbekommen, wenn der Spieler nicht online ist, nennen wir die Methode <code>playerIsOffline</code> und landen bei folgendem Code:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;

        String playerName = args[0];    // first argument is player name
        Player player = getPlayer(playerName, sender);
        
        <b>if (playerIsOffline(player, sender, playerName)) return false;</b>

        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
        return true;
    }
</pre>

<p>Und zum Schluss noch der vierte Streich:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;

        String playerName = args[0];    // first argument is player name
        Player player = getPlayer(playerName, sender);
        
        if (playerIsOffline(player, sender, playerName)) return false;

        <b>if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }</b>
        return true;
    }
</pre>

<p>Diesen Teil können wir <code>handleCommand</code> nennen und wir landen bei:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (commandCannotBeHandled(sender, args)) return false;

        String playerName = args[0];    // first argument is player name
        Player player = getPlayer(playerName, sender);
        
        if (playerIsOffline(player, sender, playerName)) return false;

        <b>handleCommand(label, player);</b>
        return true;
    }
</pre>

<p>Du siehst, dass unser <code>onCommand</code> damit viel kürzer und leichter lesbar geworden ist. Trotzdem möchte ich, dass wir noch zwei Schönheitsfehler ausbessern.</p>

<ol>
<li>Mir gefällt der Name <code>commandCannotBeHandled</code> nicht besonders, weil er eine Verneinung beinhaltet. Besser wäre es, wenn das Ding <code>commandCanBeHandled</code> hieße und wir ein <code>!</code>(also ein <em>not</em>) davorschreiben würden. Das geht recht einfach: Du wählst die Methode <code>commandCannotBeHandled</code> aus und gehst wieder auf <strong>Refactor</strong> und dann auf <strong>Invert Boolean&hellip;</strong>. Dann benennst du die Methode um in <code>commandCanBeHandled</code> und der Rest geht schon wieder automatisch. Praktisch nicht?</li>
<li>NetBeans hat die neuen Methoden immer direkt nach der Methode <code>onCommand</code> platziert. Jetzt stehen sie in umgekehrter Reihenfolge, als sie in <code>onCommand</code> aufgerufen wurden. Daher schlage ich vor, dass wir die Reihenfolge genau umdrehen. Wenn beim herumkopieren der Methoden manchmal Einrückungen nicht mehr passen, macht das nix. Wenn du fertig bist, wähle einfach <strong>Source</strong> und dann <strong>Format</strong> aus und alles sieht wieder schön aus. Zum Schluss sollte dein File <code>Getafix.java</code> folgendermaßen aussehen:</li>
</ol>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!commandCanBeHandled(sender, args)) {
            return false;
        }

        String playerName = args[0];    // first argument is player name
        Player player = getPlayer(playerName, sender);

        if (playerIsOffline(player, sender, playerName)) {
            return false;
        }

        handleCommand(label, player);
        return true;
    }

    private boolean commandCanBeHandled(CommandSender sender, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("Command can only be used by player");
            return false;
        }
        if (args.length != 1) {
            return false;
        }
        return true;
    }

    private Player getPlayer(String playerName, CommandSender sender) {
        Player player;
        if (playerName.equalsIgnoreCase("me")) {
            player = (Player) sender;
        } else {
            player = Bukkit.getPlayer(playerName);
        }
        return player;
    }

    private boolean playerIsOffline(Player player, CommandSender sender, String playerName) {
        if (player == null) {
            sender.sendMessage("Player " + playerName + " is not online");
            return true;
        }
        return false;
    }

    private void handleCommand(String label, Player player) {
        if (label.equalsIgnoreCase("gethealth")) {
            player.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
        } else {
            player.setHealth(20.);
        }
    }
</pre>

<h3 id="eine-letzte-sache">Eine letzte Sache</h3>

<p>Du musst zugeben, dass es schon ein wenig komisch ist, dass sich dann jeder gleich selbst oder andere heilen kann, wenn er mal wo runtergefallen ist oder von einem Creeper angegriffen worden ist. Damit ist die Sache mit der Gesundheit bei den Minecraft-Spielen ziemlich witzlos geworden. Wir wollen dem entgegenwirken und sagen, dass nur mehr *op*s unsere Kommandos aufrufen dürfen.</p>

<p>Dazu kann man den <code>sender</code> mit der methode <code>sender.isOp</code> fragen, ob er op ist. Das war ja einfach. Was wäre nun eine sinnvolle Methode, in der wir unsere Abfrage platzieren könnten? Man kann sagen, dass dies ja eine Bedingung ist, ob das Kommando ausgeführt werden darf. Daher gehen wir in unsere Methode <code>commandCanBeHandled</code> und geben zu unserer Bedingung <code>!(sender instanceof Player)</code> noch dazu, dass er nicht op sein darf und ändern die Fehlermeldung leicht. Die Methode sollte dann so aussehen:</p>

<pre>
    private boolean commandCanBeHandled(CommandSender sender, String[] args) {
        <b>if (!(sender instanceof Player) || !sender.isOp()) {
            sender.sendMessage("Command can only be used by player who is op");</b>
            return false;
        }
        if (args.length != 1) {
            return false;
        }
        return true;
    }
</pre>

<p>Die Bedingung in diesem <code>if</code> Statement müssen wir folgendermaßen lesen: Wenn <code>sender</code> kein <code>Player</code> ist <em>oder</em> wenn <code>sender</code> kein op ist, dann darf das Kommando nicht ausgeführt werden. Die beiden geraden Striche (<code>||</code>) bedeuten also <em>oder</em> und damit kannst du Bedienungen in einem <code>if</code> verknüpfen. Falls du mal Bedingungen mit einem <em>und</em> verknüpfen willst, verwendest du <code>&amp;&amp;</code>.</p>

<p>Falls dir noch aufgefallen ist, dass in der Zeile <code>if (args.length != 1) {</code> am Rand eine Glühbirne angezeigt wird, kannst du ja mal draufklicken und <code>The if statement ist redundant</code> auswählen. Was passiert und warum funktioniert das?</p>

<h3 id="zusammenfassung">Zusammenfassung</h3>

<p>Jetzt sind wir fertig für heute. Ich glaube wir haben ein ziemlich tolles Programm durchgemacht und du warst wirklich fleißig. Sieh dir das Programm morgen oder in ein paar Tagen nochmals genau an und versuche genau zu verstehen, warum das alles so funktioniert. Wenn dir etwas unklar ist, schreib es auf und frage nächstes Mal deinen Mentor.</p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>In deinem Plugin vom letzten Mal in die CodeDatei <code>GetafixPlugin.java</code> gehen.</li>

<li><p>Methode <code>onCommand</code> erweitern, damit diese den folgenden Code beinhaltet:
<pre>
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    if (!(sender instanceof Player)) {
        sender.sendMessage(&ldquo;Command can only be used by player&rdquo;);
        return false;
    }</p>
<pre><code>if (args.length != 1) {
    return false;
}

String playerName = args[0];    // first argument is player name
Player player;

if (playerName.equalsIgnoreCase(&#34;me&#34;)) {
    player = (Player) sender;
} else {
    player = Bukkit.getPlayer(playerName);
}

if (player == null) {
    sender.sendMessage(&#34;Player &#34; + playerName + &#34; is not online&#34;);
}

if (label.equalsIgnoreCase(&#34;gethealth&#34;)) {
    player.sendMessage(&#34;Health of &#34; + player.getName() + &#34;: &#34; + player.getHealth());
    return true;
} else {
    player.setHealth(20.);
}
return true;</code></pre>
<p>}
</pre></p></li>

<li><p>Vereinfache den Code, indem du die ersten zwei <code>if</code> Bedingungen in eine eigene Methode auslagerst: dazu markierst du den Block, der ausgelagert werden soll, klickst mit der rechten Maustaste darauf, wählst <strong>Refactor</strong> &gt; <strong>Introduce</strong> &gt; <strong>Method</strong> aus und gibt der Methode den Name <code>argumentCannotBeHandled</code>.</p></li>

<li><p>Vereinfache den Code erneut, indem du die 5 Zeilen, in denen der <code>Player</code> initialisiert wird, auslagerst, und der neuen Methode den Namen <code>getPlayer</code> gibst.</p></li>

<li><p>Vereinfache den Code ein drittes Mal, indem du die Überprüfung, ob der <code>Player</code> online ist, auslagerst und der neuen Methode den Namen <code>playerIsOffline</code> gibst.</p></li>

<li><p>Baue ein, dass nur Operatoren die Kommandos <code>/gethealth</code> und <code>/heal</code> ausführen dürfen, indem du eine zusätzliche Überprüfung hinzufügst mit <code>!sender.isOp()</code> und eine dementsprechende Nachricht an den <code>sender</code> schickst.</p></li>

<li><p>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</p></li>

<li><p>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</p></li>

<li><p>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</p></li>

<li><p>Teste das Plugin indem du in Minecraft deine Kommandos <code>/gethealth</code> und <code>/heal</code> aufrufst.</p></li>
</ol>

<h2 id="a-name-ideas-a-ideen-für-weitere-entwicklungen"><a name="ideas"></a>Ideen für weitere Entwicklungen</h2>

<p>Falls du Lust hast kannst du ja unser Programm verändern. Einige Ideen gefällig?</p>

<ol>
<li>Man darf sich nicht mehr selber heilen. D. h. du musst <code>me</code> als mögliches Argument rausnehmen und aufpassen, dass der Name des Spielers, der geheilt werden soll nicht gleich dem Namen des Senders ist.</li>
<li>Heilen bedeutet nicht, dass man gleich auf 20 Gesundheitspunkte kommt, sondern man bekommt 3 Punkte dazu. Was passiert, wenn du jemanden, der 18 Punkte hat heilst? Hat der dann 21? Das darf natürlich nicht passieren</li>
<li>Das Kommando <code>gethealth</code> darf von jedem ausgeführt werden, aber <code>heal</code> nur von ops.</li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/06_getafix-magicpotion\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Getafix Magic Potion</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Episode wirst du noch mehr über Events lernen und außerdem lernen, wie du eine Reihe von Dingen abspeicherst</h6>
                        <p class="card-text mt-4">

<h1 id="miraculix-der-druide-teil-3">Miraculix der Druide - Teil 3</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#long">Ausführliche Anleitung</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>In der letzten Episode haben wir gelernt, wie man auf Events horchen und reagieren kann. Heute werden wir das anwenden indem wir unser Getafix-Plugin erweitern, sodass man Spielern einen Zaubertrank verabreichen kann.</p>
<pre><code>/magicpotion WorkUser</code></pre>
<p>Mit diesem Kommando (das natürlich wieder nur von ops verwendet werden darf) ist der Spieler <em>WorkUser</em> unbesiegbar, das heißt, er verliert keine Gesundheit mehr. Natürlich soll der Sender des Kommandos eine Rückmeldung bekommen, dass er den Spieler erfolgreich Zaubertrank verabreicht hat und auch der Spieler, der den Trank bekommen hat soll eine Information bekommen.</p>

<p>Außerdem werden wir noch ein Kommando <code>/listpotiondrinkers</code> implementieren, in welchem ops alle Spieler auflisten können, welche bereits einen Zaubertrank bekommen haben:</p>

<p><img src="06_getafix-MagicPotion/ListPotionDrinkers.png" alt="How the command looks like" /></p>

<h2 id="a-name-long-a-ausführliche-anleitung"><a name="long"></a>Ausführliche Anleitung</h2>

<p>Wir werden uns, wie bisher auch, schön langsam an das Thema herantasten. Der Fahrplan für diese Unit ist daher so:</p>

<ol>
<li>Wir bauen einen Event-Listener, mit einem Event-Handler, der auf das <code>EntityDamageEvent</code> horcht.</li>
<li>Wir experimentieren ein bisschen rum um herauszufinden, was dieses Event alles auslöst und sehen uns dabei das API dieses Events genauer an.</li>
<li>Wenn wir wissen, wie wir mit dem Event umgehen, werden wir das Command <code>/magicpotion</code> implementieren und dabei lernen, wie wir bequem eine Menge an Spielern abspeichern können</li>
<li>Zum Abschluss implementieren wir noch das Kommando <code>/listpotiondrinkers</code>.</li>
</ol>

<h3 id="der-event-listener">Der Event-Listener</h3>

<p>Wir beginnen mit dem Bauen des Event-Listeners, das dir schon aus der letzten Episode bekannt ist. Ich sage dir nur den Namen des Events, damit du weißt, welchen Parameter du verwenden sollst: <code>EntityDamageEvent</code>. Damit kannst du mit der <em>Zusammenfassung für Profis</em> aus der letzten Episode den Event-Handler aufbauen. Bau ihn einfach so, dass beim Auftreten des Events auf der Konsole eine Info &ldquo;Outch, something got damaged&rdquo; oder so ähnlich ausgegeben wird (Sieh nach in der Episode 2: <code>Bukkit.getLogger().info</code>, falls du unsicher bist, wie du etwas in der Konsole ausgeben kannst). Falls dir bei den Namen die Ideen ausgehen, hier meine Vorschläge:</p>

<ul>
<li>Listener-Klasse: <code>DamageListener</code></li>
<li>Event-Handler: <code>onPlayerDamage</code></li>
</ul>

<p>Dann kannst du das Projekt gleich mal bauen und testen. Versuche heraus, wann der Handler  aufgerufen wird. Der heißt nicht umsonst sehr allgemein <code>EntityDamageEvent</code>.</p>

<h3 id="das-entitydamageevent">Das <code>EntityDamageEvent</code></h3>

<p>Durch unsere Experimente haben wir gesehen, dass der Handler immer aufgerufen wird, sobald irgendetwas kaputt geht. Wir sind aber nur dann an einem Damage interessiert, wenn er einen Spieler betrifft. Beachte, dass es uns jetzt noch egal ist, ob der Spieler einen Zaubertrank getrunken hat oder nicht. Wir bauen sozusagen gerade lauter Obelixe ;-).</p>

<p>Also, wie finden wir heraus, ob der aktuelle Damage-Event sich gerade auf einen Spieler bezieht oder nicht. Als Profi wirst du schon ahnen, dass das irgendwo in unserer Rohrpost, also dem event-Objekt gespeichert ist. Die Methode <code>getEntityType</code> liefert dir den Wert zurück, der dir sagt, was gerade beschädigt wurde. Wenn du in der Methode <code>onPlayerDamage</code> einmal</p>
<pre><code>EntityType.</code></pre>
<p>eintippst (notfalls wieder mit <code>Ctrl</code> + <code>Space</code> nachhelfen), dann siehst du, wieviele verschiedene Dinge (Entities) beschädigt werden können. Und wenn du dann bis zum Buchstaben P hinunterscrollst, siehst du auch den <code>PLAYER</code>.</p>

<p>Wir handeln jetzt im Beamten-Modus: Wenns uns nix angeht, lass ma gleich die Finger davon. Also: Wenn das betroffene Entity kein <code>PLAYER</code> ist, dann verlassen wir die Methode sofort. Auf Gut-Java:</p>

<pre>
public void onDamageEvent(EntityDamageEvent event) {
    <b>if (event.getEntityType() != EntityType.PLAYER) {
            return;
    }</b>
    Bukkit.getLogger().info("Outch, someone got damaged");
}
</pre>

<p>Das probieren wir jetzt gleich wieder aus. Also bauen und testen. Du solltest jetzt sehen, dass die Meldung nur mehr ausgegeben wird, wenn ein Spieler zu Schaden kommt.</p>

<h3 id="ein-event-abbrechen">Ein Event abbrechen</h3>

<p>Jetzt wird es an der Zeit zu überlegen, was wir tun können, damit wir, falls der Spieler einen Schaden erleidet, diesen wieder gut machen. Eine erste Idee könnte sein, dass wir die bereits bekannte Methode <code>setHealth</code> verwenden und im Fall, dass ein Damage auftritt, einfach <code>setHealth(20)</code> aufrufen. Probier das einfach mal aus. Was siehst du?</p>

<p>Also bei mir hat es so mittelgut funktioniert. Wenn du leichte Schäden erleidest (zum Beispiel wenn du unter Wasser keine Luft mehr bekommst und so langsam deine Herzen verschwinden)geht es einigermaßen. Aber hast du mal probiert von großer Höhe runterzuspringen? Da ist dann ganz schnell Schluss mit Lustig. Aber warum ist das so?</p>

<p>Da müssen wir uns schnell an eine Sache aus der letzten Episode erinnern. Ziemlich zum Schluss habe ich dir vorgestellt, wie Ereignisse auf dem Bukkit-Server ablaufen. Hier nochmals zur Erinnerung:</p>

<ol>
<li>Er baut ein Event-Objekt (die Rohrpost), das den Event beschreibt</li>
<li>Er schickt die Rohrpost an alle Plugins, diese können das Event-Objekt auslesen, verändern und was weiß ich noch alles machen</li>
<li>Sobald das letzte Plugin das Event-Objekt gehabt hat, führt der Server das Event endlich aus. Dazu nimmt er aber das von den Plugins veränderte Event-Objekt her.</li>
</ol>

<p>Das heißt, dass dein Listener immer <strong>vor</strong> dem eigentlichen Event aufgerufen wird. Das heißt auch, dass du <strong>bevor</strong> der Damage wirklich passiert, deinem Spieler die maximale Gesundheit zukommen lässt. Wenn jetzt ein wirklich schlimmer Schaden passiert, wie z. B. der Fall aus ein er großen Höhe, dann nutzt das alles nix, weil der Spieler dann mehr als 20 Punkte Gesundheit verliert.</p>

<p>Also brauchen wir eine andere Strategie, und die ist, dass wir das Event einfach abbrechen. Ja das geht. Wir können dem Server also sagen, dass er das Event nicht ausführen soll und das geht mit der Methode <code>setCancelled</code> des Event-Objekts. Wenn wir <code>setCancelled</code> mit <code>true</code> aufrufen, dann bekommen zwar alle Plugins das Event noch zugesandt aber der Server selbst führt es nicht mehr aus. Das ganze sieht dann so aus:
<pre>
public void onDamageEvent(EntityDamageEvent event) {
    if (event.getEntityType() != EntityType.PLAYER) {
            return;
    }
    <b>event.setCancelled(true)</b>
    <span style="text-decoration: line-through; font-weight: bold">Bukkit.getLogger().info(&ldquo;Outch, something got damaged&rdquo;);</span>
}
</pre>
Der durchgestrichene Text soll heißen, dass du diese Zeile in deine Code einfach löschen kannst. Probiere dein Plugin jetzt aus. Jetzt sollten alle Spieler auf deinem Server unverwundbar sein.</p>

<p>Natürlich muss dein <code>plugin.yml</code> vorhanden sein und der <code>DamageListener</code> muss im Plugin in der Methode <code>onEnable()</code> registiert sein.
<pre>
@Override
public void onEnable() {
    getServer().getPluginManager().registerEvents(new DamageListener(), this);
}
</pre></p>

<h3 id="spieler-speichern">Spieler speichern</h3>

<p>Jetzt können wir den Event des Damage abfangen. Das passiert aber immer und für alle Spieler. Natürlich willst du, dass nur die Spieler, welche den Zaubertrank bekommen haben, unverwundbar sind. Und das gehen wir jetzt an.</p>

<ul>
<li>Einführung von PotionPot</li>
<li>Implementierung mit TreeSet</li>
</ul>

<p>Die Spieler werden in einem <code>TreeSet</code> gespeichert. Dazu fügst du in der Hauptklasse, in der du auch die Kommandos abfragst, eine Variable <code>potionDrinkers</code> ein, in der die Spielernamen gespeichert werden. Außerdem muss der <code>DamageListener</code> Zugriff auf das Plugin bekommen, um überprüfen zu können, ob der Spieler unverwundbar ist.</p>

<p>Das sieht dann so aus:
<pre>
public class GetafixPlugin extends JavaPlugin {</p>

<p>private TreeSet&lt;String&gt; potionDrinkers = new TreeSet&lt;String&gt;();</p>
<pre><code>@Override
public void onEnable() {
    getServer().getPluginManager().registerEvents(new DamageListener(this), this); //Übergabe des Plugins an den DamageListener
}

@Override
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    ...
    if (label.equalsIgnoreCase(&#34;magicpotion&#34;)) {
        Bukkit.getLogger().info(&#34;/magicpotion for &#34; + player.getName() + &#34;: successfully added to list of potion drinkers&#34;);
        potionDrinkers.add(player.getName());
    } 
    ...
    return true;
}

//Überprüfung, ob ein Spieler einen Zaubertrank getrunken hat.
public boolean isPotionDrinkerAllowed(String playerName) {
    return potionDrinkers.contains(playerName);
}</code></pre>
<p>}
</pre></p>

<p>Der <code>DamageListener</code> sieht dann so aus:
<pre>
public class DamageListener implements Listener {</p>
<pre><code>private GetafixPlugin plugin;

public DamageListener(GetafixPlugin plugin) {
    this.plugin = plugin;
}

@EventHandler
public void onDamageEvent(EntityDamageEvent event) {
    if (event.getEntityType() != EntityType.PLAYER) {
        return;
    }
    Player player = (Player)event.getEntity();
    if (plugin.isPotionDrinkerAllowed(player.getName())) {
        event.setCancelled(true);
    }
}</code></pre>
<p>}
</pre></p>

<h3 id="die-liste-der-leute-die-zaubertrank-getrunken-haben">Die Liste der Leute, die Zaubertrank getrunken haben</h3>

<p>Alles was du jetzt machen musst, ist ein weiteres Kommando in der <code>plugin.yml</code> Datei hinzufügen, dieses Kommando in der <code>onCommand()</code> Methode abfragen, und die Liste der Potion Drinkers ausgeben.</p>

<p><code>plugin.yml</code>
<pre></p>

<h2 id="yaml-template">YAML Template.</h2>

<hr />

<p>name: Getafix
main: io.coderdojo.lisi.minecraft.firstplugin.GetafixPlugin
version: 0.1.0
author: E. Rosemann
description: A miraculous healing plugin.
commands:
    gethealth:
        description: Displays health level of player.
        usage: /gethealth player-name
    heal:
        description: Brings your health to the top level.
        usage: /heal me | player-name
    magicpotion:
        description: Adds user to the list of potion holders.
        usage: /magicpotion me | player-name
    listpotiondrinkers:
        description: Lists all current potion holders.
        usage: /listpotiondrinkers
</pre></p>

<p><code>GetafixPlugin.java</code>
<pre>
public class GetafixPlugin extends JavaPlugin {</p>
<pre><code>private TreeSet&amp;lt;String&amp;gt; potionDrinkers = new TreeSet&amp;lt;String&amp;gt;();

@Override
public void onEnable() {
    getServer().getPluginManager().registerEvents(new DamageListener(this), this);
}

@Override
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    ...
    if (label.equalsIgnoreCase(&#34;listpotiondrinkers&#34;)) {
        Bukkit.getLogger().info(&#34;/listpotiondrinkers: &#34; + potionDrinkers.size() + &#34; potion drinkers&#34;);
        sender.sendMessage(printCurrentPotionDrinkers());
    } 
    ...
    return true;
}

private String printCurrentPotionDrinkers() {
    StringBuilder sb = new StringBuilder(&#34;List of potion drinkers: &#34;);
    if (potionDrinkers.size() &gt; 0) {
        for (String playerName : potionDrinkers) {
            sb.append(playerName);
            sb.append(&#34; &#34;);
        }
    }
    return sb.toString();
}</code></pre>
<p>}
</pre></p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>Entweder verwendest du dein altes Projekt <code>GetafixPlugin</code>, oder du erstellst ein neues Projekt (siehe auch <a href="/trainingsanleitungen/minecraft-plugins/netbeans_cheatsheet.html">hier</a>)</li>
<li>Füge eine neue Klasse namens <code>DamageListener</code> und  stelle sicher, dass nach dem Klassennamen <code>implements Listener</code> steht.</li>
<li>Füge eine Methode <code>onDamageEvent</code> mit der Annotation <code>@EventHandler</code> hinzu, mit dem <code>event</code> Parameter vom Typ <code>EntityDamageEvent</code>.
<pre>
@EventHandler
public void onDamageEvent(EntityDamageEvent event) {
    if (event.getEntityType() != EntityType.PLAYER) {
            return;
    }
    Bukkit.getLogger().info(&ldquo;Outch, someone got damaged&rdquo;);
    event.setCancelled(true);
}
</pre></li>
<li>Speichere die Spieler - siehe oben.</li>
<li>Liste alle Spieler, die Zaubertränke getrunken haben - siehe oben.</li>
<li>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</li>
<li>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</li>
<li>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</li>
<li>Teste das Plugin: wenn du den Server betrittst bzw. verlässt, sollen deine Nachrichten angezeigt werden. Wenn du eine Nachricht als Operator schickst, soll diese golden angezeigt werden.</li>
</ol>

<h2 id="a-name-ideas-a-ideen-für-weitere-entwicklungen"><a name="ideas"></a>Ideen für weitere Entwicklungen</h2>

<ol>
<li>Der Zaubertrank soll natürlich nicht unendlich lange wirken. Wie kannst du die Dauer des Zaubertranks einschränken?</li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/03_getafix-player\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Getafix Player</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Episode wirst du dich selbst heilen lernen</h6>
                        <p class="card-text mt-4">

<h1 id="miraculix-der-druide-teil-1">Miraculix der Druide - Teil 1</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#long1">Ausführliche Anleitung /gethealth</a></li>
<li><a href="#long2">Ausführliche Anleitung /heal</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>Vielleicht hast du schon einmal Asterix und Obelix gelesen oder einen der Filme angesehen. Dann wirst du dich sicherlich an den Druiden Miraculix erinnern, das ist der, der den Zaubertrank zubereiten kann. Wir werden in dieser und einigen weiteren Episoden ein Plugin programmieren, mit dem du Miraculix spielen kannst. Wir fangen damit an, dass du dich und andere Spieler sofort heilen kannst. Auch kannst du deine Gesundheit oder die Gesundheit anderer Spieler anzeigen. Dazu soll es folgende Befehle geben:</p>
<pre><code>/gethealth me
/gethealth OidaZocktYT
/heal me
/heal OidaZocktYT</code></pre>
<p>Also im Grunde zwei Kommandos:</p>

<ul>
<li><code>/gethealth</code>: Zeigt die Gesundheit von mir (<code>me</code> als Parameter) oder eines anderen Spielers (Name des anderen Spielers als Parameter) an</li>
<li><code>/heal</code>: Heilt mich oder einen anderen Spieler</li>
</ul>

<p><img src="03_getafix-Player/Command.png" alt="How the command looks like" /></p>

<p>Wenn du dich wunderst, warum das Plugin nun <em>Getafix</em> heißt, verrate ich dir, dass auf Englisch der Druide nicht Miraculix sonder Getafix heißt. Und du hast sicher schon bemerkt, dass wir Informatiker gerne Dinge in englischer Sprache benennen. Daher kommt das. Jetzt kannst du deine Englischlehrerin oder deinen Englischlehrer abtesten, ob er oder sie die wirklich wichtige Literatur auch auf Englisch gelesen hat :-).</p>

<h3 id="grundsätzliche-überlegungen">Grundsätzliche Überlegungen</h3>

<p>Jetzt wollen wir mal überlegen, was wir zum Schreiben eines Plugins, welches die Gesundheit eines Spielers ausliest und verändert, brauchen und wie wir am besten vorgehen:</p>

<ol>
<li>Wir müssen bei der Eingabe von <code>/gethealth</code> die Gesundheit des Senders ermitteln. Dazu benötigen wir eine Möglichkeit, die Gesundheit des Spielers zu ermitteln. Du erinnerst dich, dass der Spieler im <code>onCommand</code> als Parameter <code>sender</code> ansprechbar ist. Da brauchen wir dann für diesen Sender eine Methode, die irgendwas mit <code>health</code> im Namen hat. Die werden wir, nachdem du das NetBeans-Projekt angelegt hast, suchen.</li>
<li>Damit es für den Anfang schön einfach bleibt, werden wir die Geschichte mit dem <code>me</code> oder dem Namen eines anderen Spielers noch lassen und nur auf den Befehl <code>/gethealth</code> oder <code>/heal</code> (so, wie in den Screenshots oben) reagieren und immer unsere eigene Gesundheit ausgeben oder uns selbst heilen.</li>
</ol>

<h3 id="neues-netbeans-projekt-anlegen">Neues NetBeans-Projekt anlegen</h3>

<p>Anfangen tut das Ganze mit bereits bekannten Arbeitsschritten. Wir legen ein Projekt an mit dem Namen <code>Getafix</code>. Dann legst du gleich ein Package mit dem Namen <code>getafix</code> an (vergiss nicht, vorher deinen Namen plus eine Domain anzugeben. Bei mir hieße das <code>com.bajupa.getafix</code>). Falls du dich nicht mehr ganz gut erinnern kannst, sieh einfach in der Episode 2 nach, wie wir ein neues Projekt und ein neues Package angelegt haben. Zum Schluss legen wir eine neue Klasse mit dem Namen <code>Getafix</code> an (achte bitte wieder auf die Groß- und Kleinschreibung). Kurz gesagt: du musst die ersten sechs Punkte der <em>Zusammenfassung für Profis</em> aus der zweiten Episode abgearbeitet haben.</p>

<p>Da das jetzt nicht mehr alles ganz neu ist für dich, wollen wir uns an dieser Stelle noch ein klein bisschen genauer umsehen. Du erinnerst dich, dass wir vom Parameter <code>sender</code> verschiedene Methoden aufrufen konnten (<code>sendMessage</code> und <code>getName</code> im letzten Fall). Vielleicht hast du das letzte Mal schon bemerkt, dass, sobald du nach <code>sender</code> einen Punkt eintippst, ein Menü erscheint, in welchem alle Methoden, die du hier aufrufen kannst, aufgelistet sind. Falls das nicht der Fall ist, kannst du mit <code>Strg</code> und <code>Space</code> (also die große Taste unten für das Leerzeichen) nachhelfen, dass das Menü auch wirklich kommt. Dann sollte das ganze ca. so aussehen. Probiere es gleich mal aus:</p>

<p><img src="03_getafix-Player/AvailableMethods.png" alt="Get menu of available methods and properties" /></p>

<p>Wenn du dich in dem Menü ein wenig umsiehst, kannst du alle verfügbaren Methoden für <code>sender</code> ansehen. Unter diesem Menü solltest du noch folgendes Fenster sehen.</p>

<p><img src="03_getafix-Player/MissingJavadoc.png" alt="Javadoc info with missing Javadoc" /></p>

<p>Das ist jetzt noch nicht sonderlich hilfreich, weil eine Fehlermeldung drinsteht. Das wollen wir ändern, dass da immer eine genauere Beschreibung der Methode, die du gerade ausgewählt hast, drinstehen. Dazu müssen wir die fehlende Dokumentation noch dazulinken. Dazu klickst du auf <code>Attach Javadoc...</code> und im darauffolgenden Fenster klickst du zuerst auf <strong>Add URL&hellip;</strong> und dann tippst du <code>https://hub.spigotmc.org/javadocs/bukkit/</code> bei <strong>Remote Javadoc URL</strong> ein.</p>

<p><img src="03_getafix-Player/SelectJavadoc.png" alt="Javadoc info with missing Javadoc" /></p>

<p>Nun solltest du für jede Methode eine kurze Beschreibung bekommen. Ich weiß ja nicht, wie es dir geht, aber zum Thema Gesundheit kann ich beim <code>sender</code> kein wirkliches Angebot finden. Damit wir hier weiterkommen, muss ich dir noch kurz eine Geschichte erzählen. Dauert auch nicht lange, versprochen:</p>

<h3 id="über-menschen-berufe-variablen-parameter-und-datentypen">Über Menschen, Berufe, Variablen, Parameter und Datentypen</h3>

<p>In der letzten Episode, als wir das erste Plugin geschrieben haben, war ich ein bisschen schlampig bei meinen Erklärungen. Du erinnerst dich sicher noch an den Parameter <code>sender</code>, mit dem wir die Spielerin, die das Kommando eingetippt hat &ldquo;ansprechen&rdquo; konnten und ihr eine Nachricht mit Hilfe der Methode <code>sendMessage</code> senden konnten.</p>

<p>Ja gut und ich habe dir gar nicht gesagt, warum das so funktioniert, weil ich wollte, dass wir ganz schnell unser Plugin fertig bekommen. Diese Sache hole ich jetzt nach. Du erinnerst dich ja noch, dass die leere Methode <code>onCommand</code> so ausgesehen hat:</p>
<pre><code>public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    return true;
}</code></pre>
<p>Wir haben dann gesagt, dass in den runden Klammern die Parameter stehen, damit man der Methode bestimmte Informationen, die sie zum Arbeiten braucht, &ldquo;mitgeben&rdquo; kann. So wie oben den Sender des Kommandos, also den, der das Kommando eingetippt hat.</p>

<p>Dabei ist nun folgendes zu beachten: <code>sender</code> ist der <em>Name</em> des Parameters und <code>CommandSender</code> der <em>Typ</em> des Parameters. Das ist ein bisschen so, wie im echten Leben mit den Menschen und ihren Berufen. Beispielsweise könnten wir sagen, dass in dem Falle, dass irgendwo gearbeitet wird, wir einen Tischler und einen Programmierer brauchen. &ldquo;Anton ist ein Tischler&rdquo; und &ldquo;Sophia ist eine Programmiererin&rdquo;. In Java-Notation könnte das dann so aussehen:</p>
<pre><code>public boolean onWork(Joiner anton, Programmer sophia) {
    return true;
}</code></pre>
<p>Also <code>onWork</code> ist der Name der Methode und <code>anton</code> und <code>sophia</code> sind die Parameter. Wir werden noch eine andere Schreibweise kennenlernen:</p>
<pre><code>Joiner anton;
Programmer sophia;</code></pre>
<p>Das werden wir dann verwenden, wenn wir in einer Methode kurz mal jemanden mit einem bestimmten Beruf benötigen (äh, einen Namen mit einem bestimmten Typ natürlich). In diesem Fall sagen wir nicht <em>Parameter</em> sondern <em>Variable</em>, sonst ist es aber das gleiche.</p>

<p>Ja, Java ist eine etwas schlichte Sprache, aber so ist das nun mal. Außerdem schreiben wir Namen in Java immer klein, dafür die &ldquo;Berufe&rdquo; (eigentlich sprechen wir von Datentypen) immer groß. Auf unser Beispiel oben angewendet können wir jetzt sagen &ldquo;<code>sender</code> ist ein <code>CommandSender</code>&rdquo;.</p>

<p>Wie im echten Leben auch, können wir Menschen mit unterschiedlichen Berufen unterschiedliche &ldquo;Befehle&rdquo; geben. Einem Tischler können wir sagen &ldquo;baue mir bitte ein Wohnzimmer&rdquo; und er wird das machen können. Eine Programmiererin können wir bitten &ldquo;schreibe mir ein Minecraft-Plugin&rdquo;. In Java würde das vielleicht dann so aussehen</p>
<pre><code>Joiner anton;
Programmer sophia;

anton.buildLivingRoom();
sophia.writeMinecraftPlugin();</code></pre>
<p>Habe ich schon erwähnt, dass Java (wie die meisten Programmiersprachen) sehr schlicht ist und nicht viel Platz für Höflichkeitsfloskeln lässt? Also zusammengefasst: Welche Befehle ich einer Person (sinnvoll) geben kann, hängt von ihrem Beruf ab. In Informatikersprache heißt das: Welche Methoden ich bei einer Variable (Parameter) aufrufen kann hängt von ihrem (seinem) Datentyp ab.</p>

<p>Jetzt, da du das verstanden hast, kannst du dir auch vorstellen, dass du den Namen <code>sender</code> im <code>onCommand</code> ändern kannst, ohne dass die Funktionalität leiden würde. Wie im echten Leben kannst du deine Kinder nennen, wie du magst. Wenn du aber den Datentyp <code>CommandSender</code> ändern würdest, dann würde plötzlich nix mehr funktionieren, weil das <code>onCommand</code> als ersten Parameter einen <code>CommandSender</code> erwartet. Wieder hilft uns das echte Leben: Wenn du neue Möbel für dein Wohnzimmer brauchst, dann willst du einen Tischler und keinen Programmierer.</p>

<h2 id="a-name-long1-a-ausführliche-anleitung-gethealth"><a name="long1"></a>Ausführliche Anleitung /gethealth</h2>

<p>Wir beginnen mit einem einfachen Fall. Sobald der Spieler <code>/gethealth</code> im Spiel eingibt, soll die Gesundheit als Zahl zwischen 0 und 20 ausgegeben werden. Also sehen wir uns den Typ des Parameters <code>sender</code> einmal an. Das ist ein <code>CommandSender</code> und wenn du nun <code>sender.</code> in einer Zeile der Methode <code>onCommand</code> eintippst, dann siehst du, was so ein <code>CommandSender</code> alles kann. Du wirst feststellen, dass der aber mit Gesundheit nix am Hut hat, weil wir keine Methode finden, die irgendwo &ldquo;Health&rdquo; im Namen hat. Aber es gibt einen anderen Datentypen, nämlich <code>Player</code>, der den Spieler in einem Minecraft-Game genauer spezifiziert. Genauer gesagt ist ein <code>Player</code> auch ein <code>CommandSender</code>und kann aber noch um einiges mehr. Du kannst das ausprobieren, indem du folgendes eintippst:
<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>Player player;</b>
        <b>player.</b>
        return true;
    }
</pre></p>

<p>Jetzt sollte das Menü mit den verfügbaren Methoden ein wenig länger sein. Du findest auch alle Methoden vom <code>CommandSender</code> wieder und eben noch mehr. Besonders auffallen sollten dir die Methoden <code>getHealth</code> und <code>setHealth</code>.</p>

<p>Wenn also der <code>sender</code> nicht nur ein <code>CommandSender</code> sondern auch ein <code>Player</code> ist (und das ist er auf jeden Fall, wenn ein Spieler unser Command <code>/gethealth</code> eingibt), dann könnten wir auf das viel umfangreichere Methodenangebot von <code>Player</code> zurückgreifen. Dazu brauchen wir nur noch einen Trick, wie wir aus einem <code>CommandSender</code> einen <code>Player</code> machen können. Dazu legen wir uns eine Variable vom Type <code>Player</code> an und weisen ihr den sender zu. Das sieht dann folgendermaßen aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>Player player = sender;</b>
        return true;
    }
</pre>

<p>Du wirst aber sehen, dass der Compiler noch nicht einverstanden ist. <code>incompatible types: CommandSender cannot be converted to Player</code> meint er und hat aber auch gleich mehrere Lösungsvorschläge. Wir nehmen den ersten, also wir <em>casten</em> den <code>sender</code> in einen <code>Player</code>.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        Player player = <b>(Player)</b>sender;
        return true;
    }
</pre>

<p>Nun ist die Variable <code>player</code> der Player, welcher das Kommando abgeschickt hat und wir haben den vollen Zugriff auf alle Methoden von <code>Player</code>. Und das nutzen wir gleich schamlos aus und geben die Gesundheit des Spielers aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        Player player = (Player) sender;
        <b>sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());</b>
        return true;
    }
</pre>

<p>Jetzt fehlt uns noch das <code>plugin.yml</code>:</p>
<pre><code>## YAML Template.
---
name: Getafix
main: com.bajupa.getafix.Getafix
version: 0.1.0
authors:
    - P. Bauer
description: A miraculous healing plugin.
commands:
    gethealth:
        description: Displays health level of player.
        usage: /gethealth &lt;player name&gt;</code></pre>
<p>Damit kannst du das Plugin nun bauen und aus dem <code>dist</code> Verzeichnis in dein Testserver-Verzeichnis kopieren, den Server starten und dich dann von deinem Minecraft-Client aus mit deinem Server verbinden.</p>

<p>Als erstes achte darauf, dass du im survival mode bist (unten am Schirm sind Herzen und Becher zu sehen, die deine Gesundheit und deine Sättigung anzeigen). Wenn du das nicht siehst, dann tippe als erstes das Kommando <code>/gamemode 0</code> ein. Probiere gleich aus, wie dein health level ist, indem du <code>/gethealth</code> eintippst. Dann lass dich von einem größeren Blockhaufen runterfallen oder mach sonst etwas, das deine Gesundheit verschlechtert und gib das Kommando nochmals ein.</p>

<h3 id="eine-notwendige-erweiterung">Eine notwendige Erweiterung</h3>

<p>Wir können ja alle Minecraft-Befehle (also auch die von Plugins) in der Server-Konsole eintippen. Das probierst du am besten auch gleich aus. Achte darauf, dass in diesem Fall <strong>kein</strong> Schrägstrich davorkommt.</p>

<p>Und hast du schon probiert? Da haben wir nämlich jetzt den Salat und der heißt <em>Exception</em>. Wenn eine Exception passiert, dann heißt das immer, dass der Programmierer Mist gebaut hat und das wollen wir ja nun wirklich nicht auf uns sitzen lassen. Daher schauen wir uns das mal ein wenig genauer an:</p>
<pre><code>[16:32:03 WARN]: Unexpected exception while parsing console command &#34;gethealth&#34;
org.bukkit.command.CommandException: Unhandled exception executing command &#39;gethealth&#39; in plugin FirstPlugin v0.1.0
at org.bukkit.command.PluginCommand.execute(PluginCommand.java:46) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.command.SimpleCommandMap.dispatch(SimpleCommandMap.java:141) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchCommand(CraftServer.java:640) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchServerCommand(CraftServer.java:626) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.DedicatedServer.aO(DedicatedServer.java:411) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.DedicatedServer.B(DedicatedServer.java:375) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.MinecraftServer.A(MinecraftServer.java:653) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at net.minecraft.server.v1_8_R3.MinecraftServer.run(MinecraftServer.java:556) [craftbukkit.jar:git-Spigot-6d16e64-b105298]
at java.lang.Thread.run(Thread.java:745) [?:1.8.0_31]
Caused by: java.lang.ClassCastException: org.bukkit.craftbukkit.v1_8_R3.command.ColouredConsoleSender cannot be cast to org.bukkit.entity.Player
at com.bajupa.getafix.Getafix.onCommand(Getafix.java:39) ~[?:?]
at org.bukkit.command.PluginCommand.execute(PluginCommand.java:44) ~[craftbukkit.jar:git-Spigot-6d16e64-b105298]
... 8 more</code></pre>
<p>Da braucht man durchaus gute Magennerven um durch diese Lawine an Kauderwelsch durchzugraben. Daher gebe ich dir den Tipp, in der siebten Zeile von unten, bei der Stelle, die mit <em>Caused by:</em> anfängt, mit dem Lesen zu beginnen.</p>

<p><code>org.bukkit.craftbukkit.v1_8_R3.command.ColouredConsoleSender cannot be cast to org.bukkit.entity.Player</code> steht da und weiters <code>at com.bajupa.getafix.Getafix.onCommand(Getafix.java:39)</code>. Der erste Teil sagt uns, dass wir <code>ColouredConsoleSender</code> nicht in einen <code>Player</code> casten können. Das ist ja auch verständlich, weil die Console halt wirklich kein Player ist. Der zweite Teil sagt uns, dass der Schlamassel in Zeile 39 passiert ist. Vielleicht steht da bei dir eine andere Zeilennummer. Wenn du jedenfalls im NetBeans auf die Zeilennummer, die bei dir steht schaust, dann siehst du, dass das (wenig überraschend) die Zeile <code>Player player = (Player) sender;</code> ist. Wenn deine Plugins größer werden, kann das aber sehr hilfreich sein, wenn du hier rauslesen kannst, in welcher Zeile dein Fehler passiert ist.</p>

<p>Also Houston, wir haben ein Problem: Wenn jemand in der Console seine eigene Health abrufen will, muss das unweigerlich in die Hose gehen. Wie lösen wir das? Was brauchen wir zur Lösung?</p>

<ol>
<li>Wir müssen eine Möglichkeit haben um rauszufinden, ob der <code>sender</code> vom Datentyp <code>Player</code> ist.</li>
<li>Wir dürfen unseren code nur dann ausführen, wenn der <code>sender</code> vom Datentyp <code>Player</code> ist</li>
<li>Freundlich wäre, wenn wir, falls der <code>sender</code> <strong>nicht</strong> vom Datentyp <code>Player</code> ist, dem <code>sender</code> mitteilten, dass er eben kein <code>Player</code> ist und deswegen er keine Gesundheitsdaten hat, der Arme.</li>
</ol>

<p>Zum Glück gibts für alle drei Dinge eine Lösung. Also der Reihe nach:
<ol>
<li> <code>sender instanceof Player</code> ist eine Aussage, die eindeutig mit wahr oder falsch beantwortet werden kann (so ähnlich wie &ldquo;jetzt scheint die Sonne&rdquo;). Wenn ein Spieler im Spiel unser Command aufruft, ist <code>sender instanceof Player</code> wahr (auf Englisch <code>true</code>), wenn jemand in der Console unser Command aufruft ist <code>sender instanceof Player</code> aber falsch (auf Englisch <code>false</code>)</li></p>

<p><li>Wenn wir Code ausführen wollen, der nur im Fall, wenn die Aussage <code>sender instanceof Player</code> wahr ist dann gibt es in Java das schöne Wort <code>if</code>. Insgesamt sieht das dann so aus:</p>

<pre>
if (sender instanceof Player) {
}
</pre>

<p>Achte darauf, dass die Aussage (meistens sagen wir einfach die Bedingung) in einem runden Klammernpaar geschrieben werden muss (so ähnlich wie die Parameter einer Methode). Zwischen den geschwungenen Klammern kommt dann der Code, der ausgeführt werden soll, wenn die Bedingung wahr ist.
</li></p>

<p><li>Für den Fall, dass die Aussage nicht wahr ist, und wir in diesem Fall anderen Code ausführen wollen, gibt es das Wort <code>else</code>. Alles zusammen sieht das dann so aus:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (sender instanceof Player) {</b>
            Player player = (Player) sender;
            sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        <b>}</b>
        <b>else {
            sender.sendMessage("Poor guy you are no player -> no health data available");
            return false;
        }</b>
     }
</pre>
</li>
</ol>
Gut, dann bauen und testen!

## <a name="long2"></a>Ausführliche Anleitung /heal

### Das yml-file erweitern
Wir müssen unser Plugin so umschreiben, dass es nun auf zwei verschiedene Kommandos reagiert. Beginnen wir einmal damit, dass es überhaupt auf ein weiteres Kommando reagiert. Dazu erweitern wir das `plugin.yml`.

<pre>
    ## YAML Template.
    ---
    name: Getafix
    main: com.bajupa.getafix.Getafix
    version: 0.<b>2</b>.0
    authors:
        - P. Bauer
    description: A miraculous healing plugin.
    commands:
        gethealth:
            description: Displays health level of player.
            usage: /gethealth me | player-name
        <b>heal:
            description: Brings your health to the top level.
            usage: /heal me | player-name
        </b>
</pre>

<p>Wir probieren das gleich aus, ob es funktioniert. Also baust du und dann kannst du in deinem Testserver-Verzeichnis einen weiteren Ordner namens <strong>update</strong> anlegen und dort kopierst du nun das <code>Getafix.jar</code> rein. Wenn dein Server vom letzten Test noch läuft, dann tippst du in der Konsole einfach <code>reload</code> ein und das neue jar-File wird geladen. Du erkennst es daran, dass das <strong>update</strong>-Verzeichnis nun leer ist. Wenn du nun <code>heal</code> in die Konsole eintippst bekommst du die Fehlermeldung, dass du in der Konsole keine Gesundheitsdaten zur Verfügung hast. Das ist noch nicht ideal, aber logisch, weil ja noch nix programmiert wurde. Wir sehen aber, dass unser Plugin schon mal auf den neuen Befehl reagiert.</p>

<h3 id="wieder-ein-paar-überlegungen">Wieder ein paar Überlegungen</h3>

<p>Nun müssen wir uns überlegen, was wir eigentlich wollen.</p>

<ol>
<li>Wir wollen unterscheiden, welches Kommando der Sender jetzt eingetippt hat. Dazu können wir einen weiteren Parameter, nämlich <code>label</code> verwenden.</li>
<li>Wir wollen, je nachdem, welches Kommando eingegeben wurde, unterschiedliche Code-Teile ausführen. Da klingelt&rsquo;s wahrscheinlich schon: das wird wieder einmal ein Fall für unser <code>if</code>.</li>
</ol>

<p>Naja, das sieht ja schon ganz gut aus.</p>

<h3 id="erste-code-erweiterungen">Erste Code-Erweiterungen</h3>

<p>Als erstes sehen wir uns die Sache mit dem <code>label</code> an. Du erinnerst dich? <code>label</code> ist der Name und <code>String</code> ist der Datentyp. <code>String</code>s sind Zeichenketten, das hatten wir schon mal bei der Methode <code>sendMessage</code>, der wir einen Text zum Anzeigen mitgegeben haben und das war auch der mit dem + zum Aneinanderkleben von mehreren Strings. So ein String kann aber noch mehr.</p>

<p>Als erstes sehen wir uns aber an, ob im <code>label</code> auch wirklich das Kommando drinnensteht. Da wir mit <code>sendMessage</code> eine Methode haben, einen String auszugeben benutzen wir das gleich mal:</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>sender.sendMessage("Label: " + label);</b>
        if (sender instanceof Player) {
            Player player = (Player) sender;
            sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
            return true;
        }
        else {
            sender.sendMessage("Poor guy you are no player -> no health data available");
            return false;
        }
     }
</pre>

<p>Wenn du das jetzt baust und das jar neu lädst müsste bei Aufruf von <code>/gethealth</code> oder auch <code>/heal</code> immer das Kommando, das du eingegeben hast, ausgegeben werden. Naja, damit haben wir doch schon mal unser Unterscheidungskriterium. Jetzt wollen wir das ganze in ein <code>if</code> verpacken und dann haben wir wieder schön unterscheidbare Code-Teile, die je nach Eingabe ausgeführt werden.</p>

<pre>
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        <b>if (label.equalsIgnoreCase("gethealth")) {</b>
            if (sender instanceof Player) {
                Player player = (Player) sender;
                sender.sendMessage("Health of " + player.getName() + ": " + player.getHealth());
                return true;
            }
            else {
                sender.sendMessage("Poor guy you are no player -> no health data available");
                return false;
            }
        <b>}
        else {
            sender.sendMessage("Healing will be done later, sorry");
            return true;
        }</b>
     }
</pre>

<p>Gut, das <code>label.equalsIgnoreCase(&quot;gethealth&quot;)</code> ist vielleicht noch eine kleine Erklärung wert: Also, wir wissen, dass <code>label</code> vom Datentyp <code>String</code> ist und Strings können ein paar Dinge (Denke wieder an die Berufe). Eines davon ist sich selbst mit einem anderen String zu vergleichen. Das ist <code>equals</code>, welches ein <code>true</code> (wahr) zurückgibt, wenn der String, der als Parameter mitgegeben wird gleich ist und <code>false</code>, wenn nicht.</p>

<p>Das <code>equals</code> achtet aber auf Groß- und Kleinschreibung und damit würde das Kommando <code>/getHealth</code> nicht mehr erkannt werden (<code>equals</code> würde <code>false</code> zurückgeben). Damit das nicht passiert, gibt es <code>equalsIgnoreCase</code>, das eben über Groß- und Kleinschreibschwächen hinwegsieht.</p>

<p>Zum Schluss dieser Episode wollen wir noch den Code einfügen, der eigentlich gemacht werden soll, wenn der Spieler <code>/heal</code> eingibt. Wie immer dazu &hellip;</p>

<h3 id="ein-paar-weitere-kleine-überlegungen">Ein paar weitere kleine Überlegungen</h3>

<ol>
<li>Wie bei <code>gethealth</code> werden wir diese Überprüfung mit <code>instanceof Player</code> brauchen und dann wieder den <code>sender</code> auf einen <code>Player</code> casten (merkst du, dass wir schon wie echte Informatiker sprechen, das heißt, dass dich deine Großeltern sicher nimmer verstehen).</li>
<li>Wir brauchen eine Methode von <code>Player</code>, um dessen Gesundheit zu verändern. Das ist die Methode <code>setHealth</code>.</li>
</ol>

<p>###Letzte Code-Erweiterung
Da habe ich jetzt einen Vorschlag. Das probierst du jetzt schnell mal selber. Die Mentoren können dir dabei helfen. Außerdem gibt es in der nächsten Episode natürlich die Auflösung. Viel Spaß</p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>Neues Projekt anlegen: Menüpunkt <strong>File</strong> &gt; <strong>New Project</strong>, in Choose Project: <strong>Java</strong> &gt; <strong>Java Class Library</strong> mit Projektnamen <code>GetafixPlugin</code></li>
<li><code>craftbukkit.jar</code> zu den Libraries dazufügen: Rechte Maus-Klick auf <strong>Libraries</strong> &gt; <strong>Add JAR/Folder</strong></li>
<li>Package anlegen: Rechte Maus-Klick auf <strong>Source Packages</strong>, Auswahl von <strong>New</strong> &gt; <strong>Java Package</strong> mit Package Name z.B. <code>io.coderdojo.&lt;dein-name&gt;.getafix</code></li>
<li>Klasse anlegen: Rechte Maus-Klick auf das eben erstellte Package, Auswahl von <strong>New</strong> &gt; <strong>Java Class</strong> mit Class Name z.B. <code>GetafixPlugin</code></li>
<li><code>extends JavaPlugin</code> nach dem Klassennamen dazuschreiben</li>
<li>Methode <code>onCommand</code> generieren: Rechte Maus-Klick im Editor zwischen den geschwungenen Klammern &gt; <strong>Inserter Code</strong> &gt; <strong>Override Method</strong> &gt; Auswahl von <code>onCommand</code> &gt; <strong>Generate</strong></li>
<li>Die Methode ausprogrammieren, also reinschreiben, was geschehen soll, wenn eines der Kommandos aufgerufen wird:
<pre>
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    if (label.equalsIgnoreCase(&ldquo;gethealth&rdquo;)) {
        if (sender instanceof Player) {
            Player player = (Player) sender;
            player.sendMessage(&ldquo;Health of &rdquo; + player.getName() + &ldquo;: &ldquo; + player.getHealth());
            return true;
        } else {
            sender.sendMessage(&ldquo;Poor guy you are no player -&gt; no health data available&rdquo;);
            return false;
        }
    } else {
        //Aufgabe 1: Stelle sicher, dass nur Spieler geheilt werden können.
        //Aufgabe 2: Heile den Spieler, wenn du weißt dass du die Methode <code>setHealth</code> für den <code>player</code> aufrufen musst?
        //Aufgabe 3: Schreibe dem Spieler, dass du ihn geheilt hast, einmal auf der Minecraft Console, und einmal als Log Statement
        return true;
    }
}
</pre></li>
<li><code>plugin.yml</code> zum Projekt hinzufügen: Rechte Maus-Klick auf <strong>Source Packages</strong> &gt; <strong>New</strong> auswählen &gt; <strong>YAML File</strong> mit File Name <code>plugin</code></li>

<li><p>Die Details im <code>plugin.yml</code> eingeben, wobei du die Details in den eckigen Klammern [] durch deine Werte ersetzt:
<pre></p>

<h2 id="yaml-template">YAML Template.</h2>

<hr />

<p>name: Getafix
main: [Package Name].[Class Name]
version: 0.1.0
author: [dein Name]
description: A miraculous healing plugin.
commands:
    gethealth:
        description: Displays health level of player.
        usage: /gethealth player-name
    heal:
        description: Brings your health to the top level.
        usage: /heal me | player-name
</pre></p></li>

<li><p>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</p></li>

<li><p>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</p></li>

<li><p>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</p></li>

<li><p>Teste das Plugin indem du in Minecraft deine Kommandos <code>/gethealth</code> und <code>/heal</code> aufrufst.</p></li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/08_scriptcraft_basics\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Grundlagen von Minecraft Mods mit JavaScript</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Anleitung lernst du erste Grundlagen, wie man Minecraft Mods mit JavaScript entwickelt.</h6>
                        <p class="card-text mt-4">

<h1 id="grundlagen-von-minecraft-mods-mit-javascript">Grundlagen von Minecraft Mods mit JavaScript</h1>

<h2 id="systemvoraussetzungen">Systemvoraussetzungen</h2>

<p>Du brauchst für diese Übungen einen Minecraft Server mit Scriptcraft. <strong>Wenn du keine Erfahrung bzgl. Konfiguration von Computern, Java etc. hast, komm ins CoderDojo und bitte eine Mentorin, dir einen solchen Server zur Verfügung zu stellen.</strong> Ansonsten hast du folgende Möglichkeiten:</p>

<ul>
<li>Folge der <a href="07_spigot_scriptcraft_docker.html" target="_blank">Anleitung auf unserer Homepage</a></li>
<li>Installiere Scriptcraft lokal auf deinem Computer (<a href="https://github.com/walterhiggins/ScriptCraft/blob/master/README.md" target="_blank">Installationsanleitung in Englisch</a>)</li>
</ul>

<p>Zum Programmieren von JavaScript brauchst du einen Texteditor. Empfehlenswert ist ein Editor, der speziell für Softwareentwicklung gedacht ist. Hier einige Links zu kostenlosen Editoren, mit denen du JavaScript gut schreiben kannst. Falls du nicht sicher bist, welchen du nehmen sollst, nimm gleich den ersten. Im Lauf der Zeit kannst du mit verschiedenen experimentieren und dich für den entscheiden, der dir am besten gefällt.</p>

<ul>
<li><a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> (Windows, MacOS, Linux)</li>
<li><a href="https://notepad-plus-plus.org/download/v6.8.2.html" target="_blank">Notepad++</a> (Windows)</li>
<li><a href="http://www.sublimetext.com/2" target="_blank">Sublime Text</a> (Windows, MacOS, Linux)</li>
<li><a href="http://brackets.io/" target="_blank">Brackets</a> (Windows, MacOS, Linux)</li>
<li><a href="https://atom.io/" target="_blank">Atom</a> (Windows, MacOS, Linux)</li>
</ul>

<p>Um diese Übung ausprobieren zu können, brauchst du das Spiel Minecraft auf deinem Computer.</p>

<h2 id="erste-schritte">Erste Schritte</h2>

<ol>
<li><p>Starte Minecraft</p></li>

<li><p><img src="08_scriptcraft_basics/minecraft-multiplayer.png" alt="Multiplayer Mode" />{: .right}
Wechsle in den <em>Multiplayer-Mode</em>.</p></li>

<li><p>Verbinde dich mit deinem Minecraft Server</p></li>

<li><p><img src="08_scriptcraft_basics/execute-interactive-js.png" alt="Interaktives JavaScript" />{: .right}
Du kannst jetzt interaktiv erste JavaScript-Kommandos als <a href="http://minecraft-de.gamepedia.com/Befehl" target="_blank">Minecraft Befehle</a> ausführen:</p>

<ul>
<li>Starte z.B. die <em>Chat-Konsole</em> mit der Taste <code>t</code>.</li>
<li>Merke dir: Jedes JavaScript-Kommando startet mit <code>/js</code>.</li>
<li>Gib ein <code>/js 1+2+3</code> und drücke <em>Enter</em>. Das Ergbnis wird angezeigt, also <code>6.0</code>.</li>
</ul></li>

<li><p>Probiere jetzt folgende Befehle aus:</p>

<ul>
<li><code>/js console.log('Hallo Server')</code> zum Ausgeben einer Meldung auf der Konsole des Minecraft Servers</li>
<li><code>/js var gruesse='Hallo Scriptcraft'</code> legt eine Variable an</li>
<li><code>/js echo(gruesse)</code> gibt die zuvor angelegte Variable in Minecraft aus</li>
<li><code>/js echo(self.name)</code> gibt deinen Namen aus. Merke dir, dass du mit <code>self</code> auf alle Daten deines Spielers zugreifen kannst.</li>
</ul></li>

<li><p>Probiere jetzt Befehle zum Bauen aus:</p>

<ul>
<li><code>/js box(blocks.oak)</code> erstellt einen Block aus Eiche (<a href="https://github.com/walterhiggins/ScriptCraft/blob/master/src/main/js/modules/blocks.js" target="_blank">Liste aller Materialien</a>)</li>
<li><code>/js box(blocks.wool.red, 5, 6, 7)</code> erstellt einen großen Block aus roter Wolle mit einer Breite von 5, einer Höhe von 6 und einer Tiefe von 7 Blöcken</li>
<li><code>/js box(blocks.glass).fwd(2).box(blocks.glass).turn().fwd(2).box(blocks.glass)</code> erstellt Blöcke mit der <em>Drohne</em> (<em>Drone</em>). Wie du siehst, kannst du sie vorwärts bewegen (<em>fwd</em>), drehen (<em>turn</em>) etc.</li>
<li><code>/js castle()</code> erstellt eine komplette Burg.</li>
<li>Stöbere durch die <a href="https://github.com/walterhiggins/ScriptCraft/blob/master/docs/API-Reference.md#drone-plugin" target="_blank"><em>Drone</em>-Dokumentation</a> und probiere verschiedene Kommandos zum Bauen aus.</li>
</ul></li>
</ol>

<p>Ein Tipp am Ende: Wenn du zu einer neuen, leeren Welt zurückkehren möchtest, starte den Minecraft-Server neu.</p>

<h2 id="entwickeln-von-scripts">Entwickeln von Scripts</h2>

<p>Erstelle mit deinem Editor im <em>plugins</em>-Verzeichns eine Datei <em>hochhaus.js</em> mit folgendem Inhalt (falls du nicht weißt wo das <em>plugins</em>-Verzeichnis ist, frage eine CoderDojo-Mentorin um Hilfe):</p>
<pre><code>var utils = require(&#39;utils&#39;);

exports.hochhaus = function (stockwerke) {
    // Erstelle eine Drohne an der Position deines Spielers
    var d = new Drone(utils.getPlayerPos(self));

    // Bewege dich eine Ebene nach oben und baue ein Rechteck aus Stein 
    d.fwd(5)
        .box0(blocks.cobblestone, 25, 1, 25);
    
    // Baue die Stockwerke mit Hilfe einer JavaScript-Schleife
    for (var i = 0; i &lt; stockwerke; i++) {
        // Baue zwei Ebenen aus Glas und oben drauf einen 
        // &#34;Deckel&#34; aus Stein.
        d.up()
            .box0(blocks.glass, 25, 1, 25)
            .up()
            .box0(blocks.glass, 25, 1, 25)
            .up()
            .box(blocks.cobblestone, 25, 1, 25);
    };
};</code></pre>
<ol>
<li><p>Starte den Minecraft-Server neu.</p></li>

<li><p>Rufe in Minecraft mit <code>/js hochhaus(3)</code> deine Funktion auf und beobachte, wie dein Script ein Hochhaus baut.<br/>
<img src="08_scriptcraft_basics/hochhaus.png" alt="Hochhaus" /></p></li>

<li><p>Ändere etwas an deinem Script (z.B. mehr oder weniger Ebenen aus Glas)</p></li>

<li><p>Lade in Minecraft deine Scripts neu mit <code>/js refresh()</code></p></li>

<li><p>Rufe deine Funktion nochmals auf und beachte, dass deine Änderung ohne Neustart des Servers wirksam geworden ist.</p></li>

<li><p>Hast du entdeckt, dass in dem Script ein Modul namens <code>utils</code> verwendet wird? Es enthält eine Menge nützlicher Hilfsfunktionen. Du kannst in der <a href="https://github.com/walterhiggins/ScriptCraft/blob/master/docs/API-Reference.md#utilities-module" target="_blank">Scriptcraft Dokumentation</a> nachlesen, was <code>utils</code> alles kann.</p></li>
</ol>

<h2 id="grundlagen-von-events">Grundlagen von Events</h2>

<p>In Mods musst do häufig auf Ereignisse reagieren (z.B. neuer Spieler meldet sich an, Block wird zerstört etc.).</p>

<p>Erstelle mit deinem Editor im <em>plugins</em>-Verzeichns eine Datei <em>welcome.js</em> mit folgendem Inhalt (falls du nicht weißt wo das <em>plugins</em>-Verzeichnis ist, frage eine CoderDojo-Mentorin um Hilfe):</p>
<pre><code>events.playerJoin(function (event) {
    echo(event.player, &#34;CoderDojo sagt Willkommen!&#34;);
});</code></pre>
<ol>
<li><p>Lade in Minecraft deine Scripts neu mit <code>/js refresh()</code></p></li>

<li><p><img src="08_scriptcraft_basics/server-disconnect.png" alt="Disconnect" />{: .right}
Melde dich vom Minecraft Server ab.</p></li>

<li><p>Melde dich erneut beim Minecraft Server an. Dein Script wird automatisch das Event <code>playerJoin</code> empfangen und die Meldung im Script in Minecraft anzeigen.<br/>
<img src="08_scriptcraft_basics/welcome-message.png" alt="Ausgabe des Events" /></p></li>

<li><p>In Minecraft gibt es hunderte von Events. Du kannst in der <a href="https://github.com/walterhiggins/ScriptCraft/blob/master/docs/API-Reference.md" target="_blank">Scriptcraft Dokumentation</a> bei Bedarf nachforschen, was es alles für Events gibt.</p></li>
</ol>

<h2 id="etwas-mehr-über-events">Etwas mehr über Events</h2>

<p>Jetzt möchten wir darauf reagieren, wenn ein Pfeil ein Objekt trifft.</p>

<p>Erstelle mit deinem Editor im <em>plugins</em>-Verzeichns eine Datei <em>arrowHit.js</em> mit folgendem Inhalt (falls du nicht weißt wo das <em>plugins</em>-Verzeichnis ist, frage eine CoderDojo-Mentorin um Hilfe):</p>
<pre><code>var fireworks = require(&#39;fireworks&#39;);

events.projectileHit(function (event) {
    var fireworkCount = 5;
    function launch() {
        fireworks.firework(event.entity.location);
        if (--fireworkCount) {
            setTimeout(launch, 2000);
        }
    }
    launch();

    event.entity.world.createExplosion(event.entity.location, 1.5);
});</code></pre>
<ol>
<li><p>Lade in Minecraft deine Scripts neu mit <code>/js refresh()</code></p></li>

<li><p>Nimm den Bogen und schieße einen Pfeil ab. Dort wo der Pfeil landet, siehst du eine Explosion und ein kurzes Feuerwerk wird abgeschossen.<br/>
<img src="08_scriptcraft_basics/fireworks.png" alt="Feuerwerk" /></p></li>

<li><p>Hast du entdeckt, dass in dem Script ein Modul namens <code>fireworks</code> verwendet wird? Du kannst in der <a href="https://github.com/walterhiggins/ScriptCraft/blob/master/docs/API-Reference.md#fireworks-module" target="_blank">Scriptcraft Dokumentation</a> nachlesen, was <code>fireworks</code> alles kann.</p></li>

<li><p>Hast du entdeckt, dass in dem Script eine Objekt namens <code>world</code> verwendet wird? Du kannst in der <a href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/World.html" target="_blank">Spigot Dokumentation</a> nachlesen, was <code>world</code> sonst noch alles kann.</p></li>
</ol>

<h2 id="jetzt-bist-du-dran">Jetzt bist du dran</h2>

<p>Erstelle aus den gelernten JavaScript-Grundlagen deinen eigenen Mod. Vielleicht hast du ein Idee für ein Mini-Game oder eine Quest, die andere dann spielen können.</p>

<p>Viele Spaß!</p>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/minecraft-server\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Installation eines Minecraft Servers</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Übung lernst du, einen Minecraft Server auf Linux zu installieren</h6>
                        <p class="card-text mt-4">

<h1 id="installation-eines-minecraft-servers">Installation eines Minecraft Servers</h1>

<h2 id="voraussetzungen">Voraussetzungen</h2>

<p>In dieser Übung installieren wir einen Minecraft Server. Als Grundlage brauchst du dafür einen Computer, auf dem <a href="https://de.wikipedia.org/wiki/Linux" target="_blank">Linux</a> installiert ist. Linux ist eine freie Software, die kostenlos im Internet zu haben ist.</p>

<p>Falls du nicht sicher bist, welches Linux du verwenden sollst, empfehlen wir für diese Übung <a href="https://www.ubuntu.com/" target="_blank">Ubuntu</a>. Du bekommst den <em>Ubuntu Server</em> zur Installation <a href="https://www.ubuntu.com/download/server" target="_blank">kostenlos im Internet</a>. Eine deutsche Anleitung zur Installation von Ubuntu findest du z.B. im <a href="https://wiki.ubuntuusers.de/Server_Installation/" target="_blank">ubuntuusers Wiki</a>.</p>

<p>Falls du keinen eigenen Server hast, sprich mit dem Mentorenteam vom CoderDojo Linz. Wir können eine limitierte Anzahl von Ubuntu-Servern, die in der <a href="https://azure.microsoft.com" target="_blank">Microsoft Azure</a> <a href="https://de.wikipedia.org/wiki/Cloud_Computing" target="_blank">Cloud</a> laufen, zur Verfügung stellen.</p>

<h2 id="zugriff-auf-deinen-ubuntu-server">Zugriff auf deinen Ubuntu-Server</h2>

<h3 id="lokales-terminal">Lokales Terminal</h3>

<p>Falls du direkten Zugriff auf den Ubuntu-Server hast, kannst du die in dieser Übung enthaltenen Schritte in einem <a href="https://wiki.ubuntuusers.de/Terminal/" target="_blank">lokalen Terminal</a> durchführen.</p>

<h3 id="secure-shell-ssh">Secure Shell (SSH)</h3>

<p>Wenn dein Server in der Cloud läuft und du keinen direkten Zugang dazu hast, musst du aus der Ferne zugreifen. Dafür verwendet man eine <a href="https://de.wikipedia.org/wiki/Secure_Shell" target="_blank">Secure Shell</a>. Üblicherweise bezeichnet sie kurz als <strong>ssh</strong>. Mit ihr kannst du aus der Ferne deinen Server administrieren, Dateien rauf und runter kopieren (<a href="https://de.wikipedia.org/wiki/Secure_Copy" target="_blank">Secure Copy</a> oder kurz <em>scp</em>) und vieles mehr.</p>

<p>Unter Windows verwendet man häufig die kostenlose Software <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" target="_blank">PuTTY</a>, um bequem mit <em>ssh</em> auf einen Linux-Server zuzugreifen. Lade die Software herunter und installiere sie. Wenn du sie startest, musst du die <a href="https://de.wikipedia.org/wiki/IP-Adresse" target="_blank">IP-Adresse</a> deines Servers eingeben. Wenn du nicht sicher bist, wo du die IP-Adresse her bekommst, bitte jemanden vom CoderDojo Mentorenteam um Hilfe.</p>

<p><img src="minecraft-server/putty-ip-adresse.jpg" alt="PuTTY" /></p>

<p>Wenn du Linux verwendest, brauchst du <em>PuTTY</em> nicht unbedingt. <em>ssh</em> ist schon eingebaut. Im <a href="https://wiki.ubuntuusers.de/SSH/" target="_blank">UbuntuUsers Wiki</a> kannst du nachlesen, wie du <em>ssh</em> unter Linux verwendest.</p>

<h3 id="filezilla">FileZilla</h3>

<p>Es kommt oft vor, dass man Dateien von seinem lokalen Computer auf seinen Server in der <a href="https://de.wikipedia.org/wiki/Cloud_Computing" target="_blank">Cloud</a> kopieren will. Das geht sehr gut mit der kostenlosen Software <a href="https://filezilla-project.org/" target="_blank">FileZilla</a>. <a href="https://wiki.filezilla-project.org/Client_Installation" target="_blank">Zur Installationsanleitung&hellip;</a></p>

<h3 id="firewall">Firewall</h3>

<p><strong>Wichtig:</strong> Damit der Zugriff auf den Server funktioniert, musst du möglicherweise die <a href="https://de.wikipedia.org/wiki/Firewall" target="_blank">Firewall</a> konfigurieren. Bitte einen CoderDojo Mentor um Hilfe, wenn du nicht weißt, wie das geht.</p>

<h2 id="minecraft-server-control-mscs">Minecraft Server Control (<em>mscs</em>)</h2>

<p>Zur Verwaltung unserer Minecraft-Welten verwenden wir <a href="https://github.com/MinecraftServerControl/mscs" target="_blank">Minecraft Server Control</a>, kurz <em>mscs</em>. Mit <em>mscs</em> kannst du unter anderem ganz einfach:</p>

<ul>
<li>neue Minecraft-Server und -Welten erstellen.</li>
<li>Welten starten und stoppen.</li>
<li>Sicherheitskopien deiner Welten erstellen.</li>
</ul>

<p><strong>Wichtiger Tipp:</strong> Wenn du wissen möchtest was <em>mscs</em> alles kann, lies unbedingt <a href="https://github.com/MinecraftServerControl/mscs#overview" target="_blank">die Dokumentation</a>. Das ist außerdem eine super Gelegenheit, um Englisch zu üben.</p>

<p>Lass uns als erstes also <em>mscs</em> installieren. Das folgende Script zeigt wie es gemacht wird. <strong>Wichtiger Tipp:</strong> Bevor du beginnst, lies die Hinweise nach dem Script, um zu verstehen was es macht.</p>
<pre><code># Aktualisieren der Installationsquellen für unseren Ubuntu-Server
sudo apt-get update</code></pre>
<ul>
<li>Zeilen, die mit <code>#</code> beginnen, sind Kommentare. Sie dienen nur zur Erklärung von Scriptcode und haben keine Funktion.</li>
<li>Das vorangestellte <code>sudo</code> sorgt dafür, dass das Kommando als <code>root</code>, also als Superuser mit Administratorrechten ausgeführt wird. <a href="https://wiki.ubuntuusers.de/sudo/" target="_blank">Mehr über <em>sudo</em>&hellip;</a></li>

<li><p>Mit <code>apt-get</code> kann man Softwarepakete verwalten. In diesem Fall wird <code>update</code> angegeben. Dadurch bringst du das Verzeichnis verfügbarer Softwarepakete auf deinem Server auf den neuesten Stand. <a href="https://wiki.ubuntuusers.de/apt/apt-get/" target="_blank">Mehr über <em>apt-get</em>&hellip;</a></p>
<pre><code># Installieren der Systemvoraussetzungen von mscs
sudo apt-get -y install openjdk-8-jre-headless perl libjson-perl libwww-perl python make wget rdiff-backup rsync socat iptables git</code></pre></li>
</ul>

<p>Mit <code>apt-get install</code> installiert man Softwarepakete. Hier werden in einer Zeile viele Pakete installiert. Sie sind alle notwendig, damit <em>mscs</em> funktioniert. Du fragst dich, woher wir wissen, was <em>mscs</em> braucht? Das kann man in der <a href="https://github.com/MinecraftServerControl/mscs" target="_blank"><em>mscs</em> Dokumentation</a> nachlesen.</p>
<pre><code># Mscs herunterladen und eigentlichen Installation starten
cd /tmp
git clone https://github.com/MinecraftServerControl/mscs.git
cd mscs
sudo make install</code></pre>
<ul>
<li><code>cd</code> steht für <em>Change Directory</em>. Du wechselst in diesem Fall in das temporäre Verzeichnis deines Linux-Servers. Dort kannst du Dateien &ldquo;zwischenlagern&rdquo;.</li>
<li>Mit <code>git clone https://github.com/...</code> lädt man Software aus <a href="https://github.com/" target="_blank">GitHub</a>. <em>mscs</em> ist dort zu finden.</li>
<li>Weil das <code>git clone</code>-Kommendo mit <code>mscs.git</code> endet, wird die Software in das Verzeichnis <code>mscs</code> kopiert. Daher müssen wir in dieses Verzeichnis wechseln.</li>
<li>Mit <code>make install</code> starten wir die eigentliche Installation. Dieser Schritt ist in der <a href="https://github.com/MinecraftServerControl/mscs" target="_blank"><em>mscs</em> Dokumentation</a> beschrieben.</li>
</ul>

<p>Wenn du das alles gemacht hast, kannst du stolz auf dich sein. Du hast <em>mscs</em> installiert und kannst jetzt Minecraft-Server damit verwalten!</p>

<h2 id="welt-erzeugen-und-spielen">Welt erzeugen und spielen</h2>

<p>Lass uns eine neue Welt erzeugen:</p>
<pre><code># Wir legen eine Welt namens myflatworld an
mscs create myflatworld 25565

# Die neue Welt taucht in der Liste an Welten auf
mscs list

# Wir können uns den Status der Welt ansehen
mscs status myflatworld

# Nachdem die neue Welt noch nicht gestartet wurde, starten wir sie
mscs start myflatworld</code></pre>
<p>An dieser Stelle können wir noch nicht zu spielen beginnen. Wir müssen erst die <a href="https://account.mojang.com/documents/minecraft_eula" target="_blank">Minecraft Lizenzbedingungen</a> (in Englisch &ldquo;End User License Agreement&rdquo; = <em>EULA</em>) akzeptieren. Das machen wir, indem wir eine Zeile in einer Datei unserer Welt ändern. Alle unsere Welten sind im Verzeichnis <code>/opt/mscs/worlds/</code> zu finden. In unserem Fall müssen wir also in das Verzeichnis <code>/opt/mscs/worlds/myflatworld</code>.</p>
<pre><code># Wechseln wir in das Verzeichnis unserer Welt
cd /opt/mscs/worlds/myflatworld

# Öffnen wir die Datei eula.txt in einem Editor
sudo nano eula.txt</code></pre>
<p>In dem Script oben kommt der Editor <em>nano</em> vor. <em>nano</em> ist ein grundlegender Editor, der bei Bedarf auf jeden System installiert werden kann. Mache dich gemeinsam mit dem Mentorenteam vom CoderDojo mit <em>nano</em> vertraut.
   * Bei Bedarf findest du eine gute <a href="https://wiki.ubuntuusers.de/Nano/" target="_blank">Einführung in <em>nano</em></a> im Internet</p>

<p>Ändere mit <em>nano</em> <code>eula=false</code> auf <code>eula=true</code> und speichere die Datei indem du die Datei mit dem Shortcut <em>Strg+O</em> und <em>Enter</em> speicherst und dann den Editor mit <em>Strg+X</em> beendest</p>
<pre><code># Starte die Welt erneut
mscs start myflatworld

# Prüfe nochmals den Status, jetzt muss die Welt gestartet sein
mscs status myflatworld</code></pre>
<p>Jetzt kannst du Minecraft starten und dich zu deinem Server verbinden. Lade deine Freunde ein, damit ihr gemeinsam in einer Welt spielen könnt.</p>

<p><img src="minecraft-server/minecraft-direkt-verbinden.png" alt="Minecraft direkt verbinden" /></p>

<h2 id="forge">Forge</h2>

<p>Für viele Mods braucht man <a href="http://minecraft-de.gamepedia.com/Mod/Minecraft_Forge" target="_blank">Minecraft Forge</a>. <em>Mscs</em> unterstützt <em>Forge</em>. Lass uns <em>Forge</em> daher installieren.</p>

<p><strong>Wichtiger Tipp:</strong> Auf der <a href="http://files.minecraftforge.net/maven/net/minecraftforge/forge/" target="_blank">Forge Webseite</a> findest du eine Liste von Programmversionen. Such dir die <em>Recommended</em>-Version (=empfohlene Version) heraus und trage die genaue Versionsnummer (z.B. <code>1.11.2-13.20.0.2228</code>) in das Installationsscript unten ein.</p>

<p><img src="minecraft-server/forge-recommended.png" alt="Forge Recommended Version" /></p>
<pre><code># Speichere die Versionsnummer in einer Variable
VER=&#34;1.11.2-13.20.0.2228&#34;

# Forge Installationsprogramm laden
cd /opt/mscs &amp;&amp; sudo mkdir server &amp;&amp; cd server
sudo wget http://files.minecraftforge.net/maven/net/minecraftforge/forge/$VER/forge-$VER-installer.jar

# Installationsprogramm starten
sudo java -jar forge-$VER-installer.jar --installServer

# Installationsprogramm löschen, es wird nicht mehr benötigt
sudo rm -f forge-$VER-installer.jar*</code></pre>
<p>Jetzt können wir eine Minecraft Welt mit <em>Forge</em> erzeugen. <strong>Wichtiger Tipp:</strong> Du musst im folgenden Script die Versionsnummer von Minecraft und den gewünschten Welt-Namen ändern.</p>
<pre><code>MINECRAFT_VER=&#34;1.11.2&#34;
WORLD_NAME=&#34;forge&#34;

# Minecraft-Welt anlegen
mscs create $WORLD_NAME 25565
cd /opt/mscs/worlds/$WORLD_NAME

# Einstellungen für die Verwendung von Forge ändern
echo &#34;mscs-client-version=$MINECRAFT_VER&#34; | sudo tee -a mscs.properties
echo &#34;mscs-server-version=$MINECRAFT_VER&#34; | sudo tee -a mscs.properties
echo &#34;mscs-server-jar=forge-$VER-universal.jar&#34; | sudo tee -a mscs.properties
echo &#34;mscs-server-url=&#34; | sudo tee -a mscs.properties

# Zu Testzwecken einen Forge Mod (Furniture) in der Welt installieren
sudo mkdir mods &amp;&amp; cd mods
sudo wget https://mrcrayfish.com/files/mods/cfm/cfm-4.1.2-mc1.11.2.jar
cd ..

# Spieleinstellungen auf kreativ und flache Welt setzen
echo &#34;gamemode=1&#34; | sudo tee -a server.properties
echo &#34;level-type=FLAT&#34; | sudo tee -a server.properties

# Lizenzbedingungen akzeptieren
echo &#34;#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://account.mojang.com/documents/minecraft_eula).&#34; | sudo tee eula.txt
echo &#34;#$(date)&#34; | sudo tee -a eula.txt
echo &#34;eula=true&#34; | sudo tee -a eula.txt</code></pre>
<p>Jetzt könnten wir die Welt eigentlich starten. Wir wollen uns selbst aber zum Op machen. Das machen wir mit Hilfe der Datei <a href="http://minecraft-de.gamepedia.com/Server.properties#ops.json" target="_blank">ops.json</a>. Du brauchst die UUID und den Namen deines Minecraft-Spielers. Wenn du die UUID nicht kennst, kannst du sie <a href="https://mcuuid.net/" target="_blank">im Internet herausfinden</a>.</p>
<pre><code>UUID=&#34;5817f013-80f7-4b0c-a3ed-2116702c4a4a&#34;
NAME=&#34;WitchCharlie&#34;
LEVEL=4

printf &#34;[\n&#34; | sudo tee ops.json
printf &#34;\t{\n&#34; | sudo tee -a ops.json
printf &#34;\t\t\&#34;uuid\&#34;: \&#34;$UUID\&#34;,\n&#34; | sudo tee -a ops.json
printf &#34;\t\t\&#34;name\&#34;: \&#34;$NAME\&#34;,\n&#34; | sudo tee -a ops.json
printf &#34;\t\t\&#34;level\&#34;: $LEVEL\n&#34; | sudo tee -a ops.json
printf &#34;\t}\n&#34; | sudo tee -a ops.json
printf &#34;]\n&#34; | sudo tee -a ops.json</code></pre>
<p>So, los gehts!</p>
<pre><code># Welt starten
mscs start $WORLD_NAME

# Bei Bedarf Ausgabe von Forge ansehen
# mscs console $WORLD_NAME</code></pre>
<p>Viel Spaß!</p>

<p><img src="minecraft-server/minecraft-mit-furniture-mod.jpg" alt="Minecraft mit Furniture Mod" /></p>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/01_installationen\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Installationen</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Übung wirst du die zum Minecraft-Plugin-Programmieren und -Testen nötige Software installieren.</h6>
                        <p class="card-text mt-4">

<h1 id="installationen">Installationen</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#java">Installation Java</a></li>
<li><a href="#netbeans">Installation NetBeans</a></li>
<li><a href="#craftbukkit">Installation Craftbukkit Server-Software</a></li>
<li><a href="#test">Mein eigener Server</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>Damit du deine Plugins bequem testen kannst, ist es sinnvoll zuerst einen Minecraft-Server auf deinem eigenen Computer zu installieren.</p>

<p>Damit dein Computer ein Minecraft-Server wird, musst du eine bestimmte Software installieren, nämlich den &ldquo;Minecraft-Server&rdquo;. Das klingt jetzt ein wenig seltsam. Das kommt daher, dass wir Informatiker das Wort &ldquo;Server&rdquo; manchmal für einen ganzen Computer benutzen (z. B. &ldquo;Der Web-Server ist heute wieder mal superschnell&rdquo;). Aber manchmal verwenden wir das Wort &ldquo;Server&rdquo; auch nur für ein Programm, die Server-Software, die einen Computer zu einem Server macht.</p>

<p>Also, um deinen Computer zu einem Minecraft-Server zu machen, musst du eine Server-Software, den &ldquo;Minecraft-Server&rdquo; installieren, alles klar?</p>

<p>Zum Testen brauchst du weiters natürlich einen Minecraft-Client und einen gültigen Minecraft-Account. Achte bitte darauf, dass sog. &ldquo;Cracked-Versions&rdquo; des Minecraft-Clients nicht funktionieren, weil man sich damit nicht auf einen anderen Server verbinden kann. Nun wären alle wichtigen Fragen geklärt und wir können loslegen.</p>

<h2 id="a-name-java-a-installation-java"><a name="java"></a>Installation Java</h2>

<p>Minecraft ist ein Java-Programm. Um Java-Programme laufen lassen zu können, musst du die Java Virtual Machine (JVM) auf deinem Computer installiert haben. Damit sich die ganze Installiererei auszahlt, ist auch noch NetBeans (das Programm, mit dem wir dann Java Programme schreiben werden) ein Java-Programm.</p>

<h3 id="ist-bei-mir-java-installiert">Ist bei mir Java installiert?</h3>

<p>Bevor wir beginnen, wollen wir nachsehen, ob eventuell Java bereits auf deinem Rechner installiert ist. Dazu öffnest du unter Windows die Eingabeaufforderung oder am Mac das Terminal. Dann tippst du folgendes ein:</p>
<pre><code>java -version</code></pre>
<p>Wenn du nun eine Antwort bekommst, die so oder zumindest so ähnlich aussieht, dann kannst du sofort zum Punkt <a href="#netbeans"><strong>Download NetBeans</strong></a> weiterspringen:</p>
<pre><code>java version &#34;1.8.0_31&#34;
Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)</code></pre>
<p>Wenn das bei dir nicht ao aussieht, dann folge bitte den Anweisungen zur Installation von Java.</p>

<h3 id="unter-windows">Unter Windows</h3>

<p>Zuerst überprüfen wir, ob du ein 32 oder 46 Bit Windows installiert hast. Dazu gehst du in die <strong>Systemsteuerung</strong>, dann wählst du den Punkt <strong>System und Sicherheit</strong> und hier <strong>System</strong>. Im darauffolgenden Fenster kannst du dann ablesen, welche Windows-Architektur du hast.</p>

<p><img src="01_installationen/CheckWinArchitectureStep2.png" alt="Check out Windows architecture" /></p>

<p>Nun öffen wir im Browser die Adresse <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> und klicken auf Java Download. Jetzt macht es sich bezahlt, wenn du dir gemerkt hast, welche Windows-Architektur du installiert hast, weil du dich hier entscheiden musst. Windows x86, wenn du ein 32-bit Windows hast, Windows x64, wenn du ein 64-bit Windows hast:</p>

<p><img src="01_installationen/SelectOs.png" alt="Select your OS" /></p>

<p>Auja, und den Radio-Button mit dem du das License Agreement akzeptierst, darfst du auch nicht vergessen, sonst wirds nix mit dem Download.</p>

<p>Wenn das exe auf deinem Computer heruntergeladen ist, startest du es und folgst den Installationsanweisungen. Wenn dir etwas komisch vorkommt, frag eineN deiner MentorInnen.</p>

<h3 id="unter-macos">Unter MacOS</h3>

<p>Du öffnest im Browser die Adresse <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> und klickst auf Java Download. Jetzt wählst du aus der Liste der möglichen Systeme Mac OS X x64 aus.</p>

<p><img src="01_installationen/SelectOs.png" alt="SelectOs" /></p>

<p>Auja, und den Radio-Button mit dem du das License Agreement akzeptierst, darfst du auch nicht vergessen, sonst wirds nix mit dem Download.</p>

<p>Wenn das dmg vollständig runtergeladen ist machst du einen Doppelklick auf das dmg in deinem Download-Folder, startest den Installer und folgst den Anweisungen. Wenn dir etwas komisch vorkommt, frag eineN deiner MentorInnen.</p>

<h3 id="großeltern-imponier-wissen">Großeltern-Imponier-Wissen</h3>

<ul>
<li>Java ist eine Programmiersprache, die auf allen verschiedenen Betriebssystemen (Windows, MacOS, Linux etc.) läuft. Damit das gut funktioniert, benötigt es die JVM (Java Virtual Machine)</li>
<li>JDK ist das <strong>J</strong>ava <strong>D</strong>evelopment <strong>K</strong>it. Das ist die Basis-Software, die man braucht, damit man Java entwickeln kann.</li>
</ul>

<h2 id="a-name-netbeans-a-installation-netbeans"><a name="netbeans"></a>Installation NetBeans</h2>

<p>Damit wir unsere Plugins in Java bequem entwickeln können, werden wir NetBeans als IDE verwenden. Wenn du diese noch nicht installiert hast, werden wir das hier machen. Glücklicherweise läuft das unter Windows und MacOS und auch Linux sehr ähnlich ab:</p>

<ol>
<li>Du gehst zur Website  <a href="https://netbeans.org/downloads/index.html" target="_blank">https://netbeans.org/downloads/index.html</a>. Dort kannst du dir aussuchen, in welcher &ldquo;Ausbaustufe&rdquo; du NetBeans haben möchtest. Wenn du genug Speicher auf deiner Festplatte oder SSD hast, würde ich die Variante &ldquo;All&rdquo; empfehlen. Damit kannst du NetBeans auch als IDE für Web-Entwicklung und C/C++-Entwicklung verwenden. Mit einem Klick auf den Button Download lädst du das gewünschte Bundle auf deinen Computer.</li>
<li>Abschließend musst du wieder das exe starten (Windows) oder das dmg öffnen und den Installer starten (Mac) und den Anweisungen im Programm folgen.</li>
<li>Abschließend kannst du dann NetBeans mal starten. Das müsste dann folgendermaßen aussehen:</li>
</ol>

<p><img src="01_installationen/NetBeansStartupPage.png" alt="NetBeans Startup Page" /></p>

<p>Gratuliere, damit haben wir bereits den Großteil unserer Vorbereitungsarbeiten geschafft.</p>

<h3 id="großeltern-imponier-wissen-1">Großeltern-Imponier-Wissen</h3>

<ul>
<li>Eine IDE ist eine Integrierte Entwicklungsumgebung (<strong>I</strong>ntegrated <strong>D</strong>evelopment <strong>E</strong>nvironment). Damit kann man sehr bequem Programme entwickeln. Bekannte Exemplare dieser Gattung sind Visual Studio, Netbeans, Eclipse, XCode, IntelliJ usw.</li>
</ul>

<h2 id="a-name-craftbukkit-a-installation-craftbukkit-server-software"><a name="craftbukkit"></a>Installation Craftbukkit Server-Software</h2>

<p>Es gibt eine Reihe von verschiedenen Servern, die wir installieren können. Die Originalfirma (Mojang) bietet zum Beispiel den Vanilla-Server an. Der hat aber den Nachteil, dass er keine Plugin-Schnittstelle zur Verfügung stellt. Die bekannteste Server-Software mit der man auch Plugins erstellen kann, ist Bukkit, welche wir auch verwenden werden. Du kannst im Internet nach der Server-Software suchen oder einfach auf die Coderdojo Website gehen und die Datei <a href="http://coderdojo-linz.github.io/trainingsanleitungen/minecraft-plugins/craftbukkit.jar" target="_blank"><code>craftbukkit.jar</code></a> auf deinen Computer herunterladen.</p>

<p>Dieses <a href="http://coderdojo-linz.github.io/trainingsanleitungen/minecraft-plugins/craftbukkit.jar" target="_blank"><code>craftbukkit.jar</code></a> ist unsere Server-Software, die wir jetzt starten müssen. Damit wir das in gewohnter Weise mit einem Doppelklick machen können, müssen wir noch eine kleine Vorkehrung treffen. Diese unterscheidet sich wieder leicht zwischen Windows und MacOS:</p>

<h3 id="windows">Windows</h3>

<p>Erstelle als erstes einen neuen Ordner mit Namen <code>bukkitServer</code> und bewege <code>craftbukkit.jar</code> da hinein. Dann starte deinen Lieblings-Texteditor (bitte nicht Word, sonder Notepad oder besser Notepad++) und tippe folgende Zeilen ab:</p>
<pre><code>java -Xms1024M -Xmx2048M -jar craftbukkit.jar -o true
pause</code></pre>
<p>Dann speicherst du die Datei unter dem Namen <code>start.bat</code> in den Ordner <code>bukkitServer</code> gleich neben <code>craftbukkit.jar</code> ab.</p>

<h3 id="macos">MacOS</h3>

<p>Erstelle als erstes einen neuen Ordner mit Namen <code>bukkitServer</code> und bewege <code>craftbukkit.jar</code> da hinein. Dann starte deinen Lieblings-Texteditor (bitte nicht Word oder Pages, sonder TextEdit oder besser Atom oder TextWrangler) und tippe folgende Zeilen ab:</p>
<pre><code>#!/bin/bash
cd &#34;$( dirname &#34;$0&#34;)&#34;
java -Xmx1024M -jar craftbukkit.jar -o true</code></pre>
<p>Dann speicherst du die Datei unter dem Namen <code>start.sh</code> in den Ordner <code>bukkitServer</code> gleich neben <code>craftbukkit.jar</code> ab.</p>

<h3 id="großeltern-imponier-wissen-2">Großeltern-Imponier-Wissen:</h3>

<ul>
<li>Ein Plugin ist ein Stück Software, mit dem man eine bestehende Software erweitert.</li>
<li>Eine Schnittstelle (auf Englisch Interface) ist eine Sammlung von Funktionen, mit der man Programme benutzen kann.</li>
</ul>

<h2 id="a-name-test-a-teste-deinen-server-das-erste-mal"><a name="test"></a>Teste deinen Server das erste Mal</h2>

<p>Wenn du diese Datei nun mit einem Doppelklick startest müsste ein Fenster mit dem Cmd-Prompt oder dem Terminal (schwarzes Fenster mit weißem Text unter Windows oder weißes Fenster mit schwarzem Text unter MacOS) erscheinen und nach einer Weile folgende Meldungen darin angezeigt werden.</p>
<pre><code>[18:22:27 INFO]: Starting minecraft server version 1.7.10
[18:22:27 INFO]: Loading properties
[18:22:27 INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info.
[18:22:27 INFO]: Stopping server
[18:22:27 INFO]: Stopping server</code></pre>
<p>Damit sind wir schon fast am Ziel. Wie du oben siehst, will der Server noch, dass wir das EULA akzeptieren. Freundlicherweise schreibt er auch, was wir tun sollen, nämlich <code>eula.txt</code> für weitere Informationen ansehen. Diese Datei wurde durch das erste Mal starten im Ordner <code>bukkitServer</code> erstellt. Wir nehmen also wieder unseren Lieblings-Editor zur Hand und öffnen dieses <code>eula.txt</code>.</p>

<p>In der letzten Zeile dieses Files steht <code>eula=false</code>. Das müssen wir in <code>eula=true</code> umschreiben und dann probieren wir es noch mal und starten den Server mit einem Doppelklick. Jetzt müsste er sauber starten. Du merkst das, dass nun im Fenster sehr viel mehr Meldungen angezeigt werden und zum Schluss die Zeile</p>
<pre><code>[18:24:04 INFO]: Done (1.369s)! For help, type &#34;help&#34; or &#34;?&#34;</code></pre>
<p>stehen sollte. Um ganz sicher zu gehen, musst du natürlich jetzt dein Minecraft starten. Um auf deinem Server spielen zu können wählst du am Startscreen die Option <strong>Multiplayer</strong>. Wenn es schnell gehen soll, klickst du auf den Button <strong>Direct Connect</strong> und gibst als Server-Adresse <code>localhost</code> ein.</p>

<p>Da wir den Server aber sicherlich öfter brauchen werden, zahlt es sich wahrscheinlich aus, dass du ihn zur Liste deiner Server hinzufügst. Dazu wählst du den Button <strong>Add Server</strong>. Dann kannst du deinem Server einen Namen geben, sodass du ihn schnell wiedererkennst und als Adresse gibst du wieder <code>localhost</code> an.</p>

<p>So jetzt solltest du dich mit dem Server verbinden können. Wenn du andere Spieler auf deinen Server einladen möchtest und diese Spieler im gleichen lokalen Netz sind wie du, musst du ihnen die IP-Number deines Computers mitteilen. Diese müssen sie dann bei Server-Adresse eingeben. Dann sollten Sie deinem Server beitreten können.</p>

<p>Gratuliere, du hast auf deinem Computer einen Minecraft-Server installiert. Auch hast du sonst schon alle Vorbereitungen getroffen, damit du in der nächsten Episode mit der Entwicklung deines ersten Plugins beginnen kannst.</p>

<h3 id="großeltern-imponier-wissen-3">Großeltern-Imponier-Wissen:</h3>

<ul>
<li>EULA ist eine Abkürzung und bedeutet <strong>E</strong>nd <strong>U</strong>ser <strong>L</strong>icense <strong>A</strong>greement, also Endbenutzer-Lizenz-Vereinbarung (danke ihr lieben JuristInnen, hüstel).</li>
<li>IP-Numbers sind Zahlenkombinationen (z. B. <code>192.168.0.3</code>) mit denen Computer in einem Netzwerk eindeutig gekennzeichnet sind. Der eigene Computer ist immer über die IP-Number <code>127.0.0.1</code> oder eben auch über den Begriff <code>localhost</code> erreichbar.</li>
</ul>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/lokaler-minecraft-server\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Lokaler Minecraft-Server mit Scriptcraft</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Übung lernst du, einen Minecraft-Server mit Scriptcraft auf deinem Computer zu installieren</h6>
                        <p class="card-text mt-4">

<h1 id="installation-eines-minecraft-servers-mit-scriptcraft">Installation eines Minecraft Servers mit Scriptcraft</h1>

<h2 id="voraussetzungen">Voraussetzungen</h2>

<p>In dieser Übung installieren wir einen Minecraft Server mit Scriptcraft auf deinem Windows-Computer.</p>

<h2 id="systemvoraussetzungen">Systemvoraussetzungen</h2>

<p>Bevor du den Minecraft-Server installieren kannst, musst du folgende Software installieren:</p>

<ol>
<li><p><em>Java SE Development Kit</em> (kurz <em>JDK</em>)<br/>
Lade die Windows-Version von der <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">Download-Seite</a> herunter und installiere sie.</p></li>

<li><p><em>Git</em><br/>
Lade die Windows-Version von der <a href="https://git-scm.com/download/win" target="_blank">Download-Seite</a> herunter und installiere sie. Installiere alle verfügbaren Teile von Git, die im Installationsprogramm auswählbar sind.</p></li>

<li><p>Lege mit dem <em>Windows Explorer</em> ein leeres Verzeichnis an, in dem wir den Minecraft-Server installieren können. Unser Vorschlag ist <code>c:\spigot</code>.</p></li>
</ol>

<h2 id="spigot">Spigot</h2>

<p>Jetzt können wir mit der Installation loslegen. Wir werden den Minecraft-Server namens <a href="https://www.spigotmc.org/" target="_blank">Spigot</a> installieren.</p>

<ol>
<li><p>Lade die <a href="https://hub.spigotmc.org/jenkins/job/BuildTools/lastStableBuild/artifact/target/BuildTools.jar" target="_blank">Installationdatei von Spigot</a> herunter und speichere sie im Installationsverzeichnis <code>c:\spigot</code>.</p></li>

<li><p>Starte das Programm <em>git bash</em><br/>
<img src="lokaler-minecraft-server/git-bash-starten.png" alt="Git Bash starten" /></p></li>

<li><p>Wechsle mit dem Kommando <code>cd /c/spigot</code> in das Installationsverzeichnis.</p></li>

<li><p>Baue den Spigot-Server mit dem Kommando <code>java -jar BuildTools.jar</code>. Hab etwas Geduld, dieser Schritt kann einige Minuten dauern.</p></li>

<li><p>Die <em>BuildTools</em> brauchen wir jetzt nicht mehr. Du kannst sie mit dem Kommando <code>rm -f BuildTools.*</code> löschen.</p></li>
</ol>

<p>Der Minecraft-Server ist jetzt fertig. Es fehlt nur noch Scriptcraft.</p>

<h2 id="scriptcraft">Scriptcraft</h2>

<p>Damit wir Minecraft mit JavaScript programmieren können, müssen wir das Plugin <em>Scriptcraft</em> installieren:</p>

<ol>
<li><p>Erstelle ein Unterverzeichnis für <em>plugins</em> mit dem Kommando <code>mkdir plugins</code>.</p></li>

<li><p>Wechsle in das Unterverzeichnis mit dem Kommando <code>cd plugins</code>.</p></li>

<li><p>Lade die <a href="https://scriptcraftjs.org/download/latest/scriptcraft-3.2.1/scriptcraft.jar" target="_blank">Scriptcraft</a> herunter und speichere es im Verzeichnis <code>c:\spigot\plugins</code>.</p></li>
</ol>

<h2 id="minecraft-server-zum-ersten-mal-starten">Minecraft Server zum ersten Mal starten</h2>

<p>Jetzt sind wir soweit, dass wir den Minecraft-Server starten können:</p>

<ol>
<li><p>Wechsle in das Installationsverzeichnis mit dem Kommando <code>cd /c/spigot</code>.</p></li>

<li><p>Starte den Minecraft-Server mit dem Kommando <code>java -jar spigot-1.11.2.jar</code>.</p></li>

<li><p>An dieser Stelle können wir noch nicht zu spielen beginnen. Wir müssen erst die <a href="https://account.mojang.com/documents/minecraft_eula" target="_blank">Minecraft Lizenzbedingungen</a> (in Englisch &ldquo;End User License Agreement&rdquo; = <em>EULA</em>) akzeptieren. Dazu öffnet man die Datei <code>eula.txt</code> und ersetzt <code>eula=false</code> durch <code>eula=true</code>.<br/>
<img src="lokaler-minecraft-server/eula-akzeptieren.png" alt="EULA akzeptieren" /></p></li>

<li><p>Starte den Minecraft-Server nochmal mit dem Kommando <code>java -jar spigot-1.11.2.jar</code>. Jetzt müsste es klappen :-)</p></li>
</ol>

<h2 id="mit-server-verbinden">Mit Server verbinden</h2>

<p>Los geht es. Starte Minecraft und verbinde dich zu deinem Server. Der Servername ist <code>localhost</code>.</p>

<p><img src="minecraft-server/minecraft-direkt-verbinden.png" alt="Minecraft verbinden" /></p>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/07_spigot_scriptcraft_docker\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Minecraft Server für ScriptCraft</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Anleitung lernst du, wie du einen Minecraft Server für ScriptCraft aufsetzt.</h6>
                        <p class="card-text mt-4">

<h1 id="minecraft-server-für-scriptcraft">Minecraft Server für ScriptCraft</h1>

<p><strong>Wichtiger Hinweis: Diese Anleitung ist für erfahrene Coder, Mentorinnen und Mentoren.</strong> Wenn du im generellen Umgang mit Linux-Servern, Docker, JRE etc. noch unerfahren bist, bitte eine Mentorin aus dem CoderDojo, den Minecraft-Server für dich herzurichten. Später kannst du dich selbst am Installieren eines MineCraft-Servers wie hier beschrieben heran wagen.</p>

<h2 id="einleitung">Einleitung</h2>

<p>Ziel dieser Anleitung ist das Betreiben eines Minecraft Servers auf Basis von <a href="https://www.spigotmc.org/wiki/about-spigot/" target="_blank">Spigot</a> mit installiertem <a href="http://scriptcraftjs.org/" target="_blank">Scriptcraft</a> Mod zum Programmieren von <a href="https://minecraft.net/de/" target="_blank">Minecraft</a> mit JavaScript.</p>

<p>Um möglichst wenig installieren zu müssen und mit wenig Ressourcen viele Server für ein CoderDojo betreiben zu können, verwenden wir <a href="https://www.docker.com/" target="_blank">Docker</a> zum Isolieren der Serverinstanzen.</p>

<h2 id="systemvoraussetzungen">Systemvoraussetzungen</h2>

<p>Man braucht <a href="https://www.docker.com/" target="_blank">Docker</a> für diese Anleitung:</p>

<ul>
<li>Unter Windows kann <a href="https://docs.docker.com/engine/installation/windows/#/docker-for-windows" target="_blank">Docker for Windows</a> verwendet werden.</li>
<li>Unter MacOS kann <a href="https://docs.docker.com/engine/installation/mac/#/docker-for-mac" target="_blank">Docker for Mac</a> verwendet werden.</li>
<li>Unter Linux kann Docker direkt verwendet werden (z.B. <a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/" target="_blank">Ubuntu</a>)</li>
</ul>

<p>Falls kein passender Rechner lokal zur Verfügung steht, ist die Verwendung eines Docker-Servers in der Cloud (z.B. <a href="https://github.com/Azure/azure-quickstart-templates/tree/master/docker-simple-on-ubuntu" target="_blank">Docker auf Azure</a>) empfehlenswert.</p>

<h2 id="basisimage">Basisimage</h2>

<p>Als Basis wurde ein <a href="https://github.com/coderdojo-linz/coderdojo-linz.github.io/tree/master/trainingsanleitungen/minecraft-plugins/07_spigot_scriptcraft_docker/base-image/Dockerfile" target="_blank">Dockerfile für Spigot mit Scriptcraft</a> erstellt. Es kann lokal wie folgt in ein Docker Image gebaut werden:</p>

<ul>
<li>Speichern des Dockerfiles in einem leeren Verzeichnis</li>
<li><code>docker build -t spigotmc .</code> (kann je nach bereits installierten Images und Internetanbindung etwas dauern)</li>
</ul>

<p>In <code>docker images</code> müsste jetzt das neue Image <code>spigotmc</code> zu sehen sein.</p>

<h2 id="images-für-spielszenarien">Images für Spielszenarien</h2>

<p>Aufbauend auf dem Basisimage können jetzt individuelle Images für verschiedene Spielszenarien erstellt werden. Für diese Anleitung haben wir ein <a href="https://github.com/coderdojo-linz/coderdojo-linz.github.io/tree/master/trainingsanleitungen/minecraft-plugins/07_spigot_scriptcraft_docker/flat-and-empty-world/Dockerfile" target="_blank">Dockerfile für eine komplett flache Welt</a> erstellt. Hier ein paar Hinweise dazu:</p>

<ul>
<li>Das Dockerfile kopiert eine <a href="https://github.com/coderdojo-linz/coderdojo-linz.github.io/tree/master/trainingsanleitungen/minecraft-plugins/07_spigot_scriptcraft_docker/flat-and-empty-world/server.properties" target="_blank">server.properties</a>-Datei. Sie kann an die jeweiligen Bedürfnisse des Spielszenarios angepasst werden. Mehr zu <em>server.properties</em> findet man <a href="http://minecraft-de.gamepedia.com/Server.properties" target="_blank">im Minecraft Wiki</a>.</li>
<li>Das Dockerfile kopiert eine <a href="https://github.com/coderdojo-linz/coderdojo-linz.github.io/tree/master/trainingsanleitungen/minecraft-plugins/07_spigot_scriptcraft_docker/flat-and-empty-world/server.properties" target="_blank">ops.json</a>-Datei. Man kann in ihr Benutzer speichern, die von Haus aus <em>Operators</em> sein sollen. Mehr dazu findet man <a href="http://minecraft-de.gamepedia.com/Server.properties#ops.json" target="_blank">im  Minecraft Wiki</a>.</li>
</ul>

<p>Ein Dockerfile für ein Spielsenario kann lokal wie folgt in ein Docker Image gebaut und gestartet werden:</p>

<ul>
<li>Speichern des Dockerfiles mit <em>server.properties</em> und <em>ops.json</em> in einem leeren Verzeichnis</li>
<li>Image bauen: <code>docker build -t mc-flat-empty .</code> (geht sehr schnell)</li>
<li>Container starten: <code>docker run -it --rm -p 25565:25565 --name mc-flat-empty -v C:\scriptcraft\flat-and-empty-world\plugins:/bin/spigotmc/scriptcraft/plugins/rainer mc-flat-empty</code>

<ul>
<li><code>-it --rm</code> sorgt dafür, dass der Container interaktiv gestartet wird (Console kann beobachtet werden) und beim Beenden des Servers automatisch gelöscht wird.</li>
<li><code>p 25565:25565</code> gibt den Minecraft Standardport am Docker Host frei. Will man mehrere Minecraft Server betreiben, kann man den Port z.B. mit <code>-p 25566:25565</code> auf <em>25566</em> ändern.</li>
<li><code>--name ...</code> vergibt einen Namen für den Container.</li>
<li><code>-v &lt;local-dir&gt;:/bin/spigotmc/scriptcraft/plugins/&lt;some-folder-name&gt;</code> mapped ein lokales Verzeichnis mit in JavaScript geschriebenen Mods in den Minecraft Container.</li>
<li><code>mc-flat-empty</code> ist der Name des oben erstellten Docker Image für das Spielsenario.</li>
</ul></li>
</ul>

<p>Hat man alles richtig gemacht, sieht das so aus:</p>
<pre><code>C:\temp\scriptcraft\flat-and-empty-world&gt;docker build -t mc-flat-empty .
Sending build context to Docker daemon 8.704 kB
Step 1 : FROM rstropek/spigotmc
 ---&gt; 4a6020e36757
Step 2 : COPY server.properties /bin/spigotmc
 ---&gt; Using cache
 ---&gt; 925c920abd91
Step 3 : COPY ops.json /bin/spigotmc
 ---&gt; Using cache
 ---&gt; 414acf0ebf53
Step 4 : CMD /bin/spigotmc/start.sh
 ---&gt; Using cache
 ---&gt; f4d15115f8fe
Successfully built f4d15115f8fe
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have &#39;-rwxr-xr-x&#39; permissions. It is recommended to double check and reset permissions for sensitive files and directories.

C:\temp\scriptcraft\flat-and-empty-world&gt;docker run -it --rm -p 25565:25565 --name mc-flat-empty -v C:\scriptcraft\flat-and-empty-world\plugins:/bin/spigotmc/scriptcraft/plugins/rainer mc-flat-empty
Loading libraries, please wait...
[07:42:49 INFO]: Starting minecraft server version 1.10.2
[07:42:49 INFO]: Loading properties
[07:42:49 INFO]: Default game type: CREATIVE
[07:42:49 INFO]: This server is running CraftBukkit version git-Spigot-72c2605-709783c (MC: 1.10.2) (Implementing API version 1.10.2-R0.1-SNAPSHOT)
...
[07:42:57 INFO]: [scriptcraft] Unzipping /bin/spigotmc/scriptcraft/modules/watcher.js (NE)
[07:42:58 WARN]: [scriptcraft] cow-clicker minigame is not yet supported in CanaryMod and Craftbukkit
[07:42:59 WARN]: [scriptcraft] Legacy ScriptCraft directory /bin/spigotmc/plugins/scriptcraft was found. This directory is no longer used.
[07:42:59 WARN]: [scriptcraft] Please put plugins in the /bin/spigotmc/scriptcraft/plugins directory
[07:42:59 INFO]: [scriptcraft] Please note that the working directory for scriptcraft v3.2.0-2016-03-19 is /bin/spigotmc/scriptcraft
[07:42:59 INFO]: Done (9.687s)! For help, type &#34;help&#34; or &#34;?&#34;
[07:42:59 INFO]: [scriptcraft] js-patch setTimeout() test complete
&gt;</code></pre>
<p>Jetzt kann man sich zum Server in Minecraft verbinden:</p>

<p><img src="07_spigot_scriptcraft_docker/join-server.png" alt="Join Server" /></p>

<h2 id="ressourcen-zum-thema-scriptcraft">Ressourcen zum Thema Scriptcraft</h2>

<ul>
<li><a href="http://scriptcraftjs.org/" target="_blank">Scriptcraft Homepage</a></li>
<li><a href="https://github.com/walterhiggins/ScriptCraft/blob/master/docs/YoungPersonsGuideToProgrammingMinecraft.md" target="_blank">Scriptcraft Guide</a></li>
<li><a href="https://github.com/walterhiggins/Writing-Minecraft-Plugins" target="_blank">Beispiele aus dem Scriptcraft Buch</a></li>
<li><a href="https://github.com/walterhiggins/ScriptCraft" target="_blank">Scriptcraft Source auf GitHub</a></li>
</ul>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/netbeans_cheatsheet\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">NetBeans Projektsetup</h5>
                        <h6 class="card-subtitle mb-2 text-muted">Eine Kurzanleitung für das Anlegen eines neuen NetBeans Projekts</h6>
                        <p class="card-text mt-4">

<h1 id="netbeans-projektsetup">NetBeans Projektsetup</h1>

<p>Kurzanleitung, wie das Projekt in NetBeans aufgesetzt werden muss, um für deine Minecraft Plugins vorbereitet zu sein.</p>

<h2 id="projekt-erstellen">Projekt erstellen</h2>

<ol>
<li>NetBeans starten</li>
<li>Menü <strong>File</strong> &gt; Menüpunkt <strong>New Project &hellip;</strong></li>
<li>Auswahl: Categories <strong>Java</strong>, Projects <strong>Java Class Library</strong> &gt; Klick auf <strong>Next</strong></li>
<li>Vergabe des Projektnamens unter <strong>Project Name</strong> (z.B. FirstPlugin) &gt; Klick auf <strong>Finish</strong></li>
</ol>

<h2 id="craftbukkit-bibliothek-hinzufügen">Craftbukkit Bibliothek hinzufügen</h2>

<ol>
<li>Auf der linken Seite (Tab <strong>Projects</strong>) auf <strong>Libraries</strong> mit der rechten Maustaste klicken &gt; <strong>Add JAR/Folder</strong> auswählen.</li>
<li>Die Datei <strong>craftbukkit.jar</strong> auswählen &gt; Klick auf <strong>Open</strong></li>
</ol>

<h2 id="package-hinzufügen">Package hinzufügen</h2>

<ol>
<li>Auf der linken Seite (Tab <strong>Projects</strong>) auf <strong>Source Packages</strong> mit der rechten Maustaste klicken &gt; <strong>New</strong> auswählen &gt; <strong>Java Package</strong> auswählen.</li>
<li>Als <strong>Package Name</strong> folgendes vergeben: io.coderdojo.<deinName>.minecraft.<pluginName> (wobei <deinName> sowie <pluginName> in Kleinschreibung ersetzt wird, z.B. durch &ldquo;lisi&rdquo; und &ldquo;firstplugin&rdquo;) &gt; Klick auf <strong>Finish</strong></li>
</ol>

<h2 id="hauptklasse-hinzufügen">Hauptklasse hinzufügen</h2>

<ol>
<li>Auf der linken Seite (Tab <strong>Projects</strong>) in <strong>Source Packages</strong> auf dein neu erstelltes Package mit der rechten Maustaste klicken &gt; <strong>New</strong> auswählen &gt; <strong>Java Class</strong> auswählen.</li>
<li>Als <strong>Class Name</strong> dein Plugin benennen, z.B. FirstPlugin &gt; Klick auf <strong>Finish</strong></li>
<li>Sicherstellen dass nach dem Klassennamen <code>extends JavaPlugin</code> steht.</li>
</ol>

<h2 id="plugin-yml-hinzufügen">plugin.yml hinzufügen</h2>

<ol>
<li>Auf der linken Seite (Tab <strong>Projects</strong>) auf <strong>Source Packages</strong> mit der rechten Maustaste klicken &gt; <strong>New</strong> auswählen &gt; <strong>YAML File</strong> auswählen.</li>
<li>Als <strong>File Name</strong> den Namen <code>plugin</code> eingeben &gt; Klick auf <strong>Finish</strong></li>
</ol>

<h2 id="resultat">Resultat</h2>

<p>Dein Projektsetup sollte jetzt so aussehen:
<img src="netbeans_cheatsheet/netbeans_structure.jpg" alt="Netbeans screenshot" /></p>

<h2 id="projekt-bauen-und-deployen">Projekt bauen und deployen</h2>

<ol>
<li>In der Icon Leiste oben auf den Hammer <strong>Build Project (F11)</strong> klicken.</li>
<li>Im Fenster <strong>Output</strong> (wenn nicht vorhanden, über Menüpunkt <strong>Window</strong> &gt; <strong>Output (Strg+4)</strong> anzeigen lassen) den Pfad zum *.jar kopieren (endet auf <code>dist/</code>).</li>
<li>Im Explorer die <code>*.jar</code> Datei aus <code>dist/</code> in den Server Plugins Ordner (<code>craftbukkit/plugins/</code>) kopieren.</li>
<li>In der Server Konsole das Kommando <code>reload</code> eingeben.</li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            

            
            
            
            
            

            

            

            

            <div class="col mb-5">
                
                <div class="card h-100" onclick="location.href='https:\/\/linz-preview.coderdojo.net\/uebungsanleitungen\/programmieren\/minecraft\/plugins\/05_welcome-listener\/'">
                
                    
                    
                    <div class="card-body">
                        
                        <span class="badge badge-pill badge-danger" style="float: right; margin-left: 10px;">
                            Level 
                        </span>
                        
                        <h5 class="card-title">Welcome Listener</h5>
                        <h6 class="card-subtitle mb-2 text-muted">In dieser Episode wirst du erste Listener programmieren</h6>
                        <p class="card-text mt-4">

<h1 id="auf-ereignisse-reagieren">Auf Ereignisse reagieren</h1>

<p>Inhalt:</p>

<ul>
<li><a href="#intro">Einleitung</a></li>
<li><a href="#long">Ausführliche Anleitung</a></li>
<li><a href="#short">Kurzversion für Profis</a></li>
</ul>

<h2 id="a-name-intro-a-einleitung"><a name="intro"></a>Einleitung</h2>

<p>Bisher haben wir in unseren Plugins immer etwas gemacht, sobald vom Spieler oder auch in der Konsole ein Kommando eingegeben wurde. Das ist ja schon ganz schön, aber manchmal ist es auch notwendig, dass wir auf Ereignisse reagieren. Ein Ereignis ist, wenn irgendetwas im Spiel passiert aber eben kein Kommando eingegeben wurde. Beispiel sind</p>

<ul>
<li>Der Spieler tritt einem Server bei</li>
<li>Es werden Chat-Nachrichten versendet</li>
<li>Es wird irgendetwas zerstört</li>
<li>Es explodiert gerade ein Block</li>
<li>Wenn ein Sign geändert wird</li>
<li>&hellip;</li>
</ul>

<p>Du kannst unter <code>org.bukkit.event.*</code> die Liste aller Events ansehen. Wir fangen nun mit einem einfachen Event an. Wenn ein neuer Spieler deinem Server beitritt wollen wir ihn freundlich begrüßen, wenn er ihn verlässt soll er freundlich verabschiedet werden. Im folgenden Screenshot siehst du die Extrabegrüßung, die dein Server dann darstellen wird.</p>

<p><img src="05_welcome-Listener/WelcomeMsg.png" alt="How the command looks like" /></p>

<p>Außerdem werden wir, wenn die Spieler miteinander chatten, die Nachrichten der ops in einer speziellen Farbe darstellen. Da diese Listender sehr gut zum Thema Begrüßen passt, kannst du sie zu deinem ersten Plugin (das mit dem <code>/sayhello</code>) dazugeben oder auch ein neues Projekt beginnen, wie du willst.</p>

<h2 id="a-name-long-a-ausführliche-anleitung"><a name="long"></a>Ausführliche Anleitung</h2>

<h3 id="die-listener-klasse">Die Listener-Klasse</h3>

<p>Wenn du dein erstes Plugin nicht erweitern willst, dann musst du wieder ein neues Projekt erstellen, ein neues Package und darin eine neue Klasse (<code>com.bajupa.welcome.Welcome</code>). Die Kurzversion, wie du dein Projekt erstellst, findest du auch <a href="/trainingsanleitungen/minecraft-plugins/netbeans_cheatsheet.html">hier</a>. Gut, jetzt sind wir bereit, unseren ersten Listener einzubauen.</p>

<p>Ein wichtiger Punkt beim Programmieren ist Ordnung zu halten. Das heißt, dass wir unser Programm so ordnen, dass nur zusammengehörige Dinge in einer Klasse sind.  Daher legen wir für den Listener eine neue Klasse an. Das kannst du ja schon gut. Ich schlage vor, dass wir die neue Klasse <code>JoinAndLeaveListener</code> nenne, weil wir da auf die beiden Events, wenn ein Spieler unserem Server beitritt und wenn ein Spieler unseren Server verlässt, reagieren wollen.</p>

<p>So ähnlich wie bei der Plugin-Klasse, welche eine Erweiterung von <code>JavaPlugin</code> ist, müssen wir einen Listener auch von einer <em>Basisklasse</em> ableiten. Das sieht dann folgendermaßen aus</p>
<pre><code>public class JoinAndLeaveListener implements Listener {

}</code></pre>
<p>Wenn du genau hinsiehst, merkst du, dass hier statt <code>extends</code> das Wörtchen <code>implements</code> steht. Sehr grob</p>

<p>In Listener-Klassen kannst du nun einen oder mehrere sog. <em>EventHandler</em> reinschreiben. Diese EventHandler sind eigentlich ganz normale Methoden, die halt nicht nach Eintippen eines Kommandos aufgerufen, sondern sobald ein Ereignis (auf Englisch eben Event) eintritt.</p>

<p>Also wollen wir unseren ersten EventHandler implementieren. Leider haben wir hier keine so tolle Unterstützung von NetBeans, dass wir einfach <strong>Source</strong> und <strong>Insert Code &hellip;</strong> auswählen könne. Diesmal müssen wir das ganze selber machen.</p>

<pre>
public class JoinAndLeaveListener implements Listener {
    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        player.sendMessage("Dear " + player.getName() + ", welcome to our server!");
    }
}
</pre>

<p>Als erstes fällt auf, dass vor der Methode die <em>Annotation</em> <code>@EventHandler</code> steht. Das ist das &ldquo;Erkennungsmerkmal&rdquo;, dass diese Methode im Falle eines Ereignisses aufgerufen wird. Anschließend kommt die Methode, welche mit <code>public void</code> beginnt. <code>void</code> heißt, dass Event Handler keinen Wert zurückgeben (vergleiche das mit dem <code>boolean</code>, der von der Methode <code>onCommand</code> zurückgegeben wird). Daran anschließend kommt der Name der Methode. Bei einem Event Handler kannst du dir den Namen (ähnlich wie bei Variablen und Parameter) aussuchen.</p>

<p>Nun kommen die Parameter und hier wird es wieder spannend. Wie du siehst, hat ein Event Handler nur einen Parameter und der ist dafür verantwortlich, dass der Event Handler beim richtigen Event aufgerufen wird. Für den Fall, dass ein Spieler einem Server beitritt gibt es den <code>PlayerJoinEvent</code> und daher wählen wir genau diesen Typ für den Parameter aus. Den Namen des Parameters darfst du dir dafür wieder selber aussuchen.</p>

<p>Zwischen den geschwungenen Klammern schreibst du jetzt rein, was zu passieren hat. In der ersten Zeile holen wir uns den Spieler, der gerade dem Server beitritt. Der wird sozusagen im Event mitgeliefert. Du kannst dir das so vorstellen: Wenn ein Ereignis auf dem Server eintritt, baut der Server ein Event-Objekt (also eine Variable mit dem Datentyp, der zu dem Event passt) zusammen und schickt dieses Objekt auf die Reise (so ähnlich wie eine Rohrpost, in der alle möglichen Informationen reingesteckt sind). Alle Event Handler, die den dazu passenden Parameter deklariert haben, bekommen diese Rohrpost und können die darin enthaltenen Informationen auslesen.</p>

<p>Also mit der Methode <code>getPlayer</code> des <code>PlayerJoinEvent</code>s kannst du den Spieler, der gerade beitritt auslesen. Wir speichern uns den Spieler in eine Variable <code>player</code> und dann holen wir uns in der nächsten Zeile von <code>player</code> den Namen mit der Methode <code>getName</code>. Das kennst du aber schon aus dem ersten Plugin.</p>

<h3 id="den-listener-registrieren">Den Listener registrieren</h3>

<p>Anders als bei der Methode <code>onCommand</code>, die es nur einmal pro Plugin gibt, kann es mehrere Listener zu verschiedenen oder auch gleichen Events geben und das ganze noch dazu in verschiedenen Plugins. Daher müssen wir Listener beim Server anmelden (registrieren), damit sie dann im Fall der Fälle auch wirklich aufgerufen werden. Dieses Anmelden machen wir in der Plugin-Klasse. Die Methode <code>onCommand</code> wäre natürlich ein möglicher Platz, das zu machen. Damit müssten wir aber ein Kommando einführen, dass irgendjemand aufrufen muss, um deine Listener zu registrieren. Das wäre aber ein wenig unbequem, wenn der Server-Administrator immer nach dem Starten per Hand die ganzen Listener aller Plugins registrieren müsste.</p>

<p>Besser ist es, wenn das automatisch geht und dafür werden wir in der Plugin-Klasse eine neue Methode einführen. Dazu holst du dir als erstes im Editor die Klasse Welcome (oder wie auch immer deine Plugin-Klasse heißt) in den Vordergrund, dann setzt du den Cursor in die Klasse und wählst wieder <strong>Source</strong> und dann <strong>Insert Code&hellip;</strong>. Genauso wie bei <code>onCommand</code> wählen wir jetzt den Punkt <strong>Override Method&hellip;</strong> aus. Das darauffolgenden Fenster sieht dann so aus:</p>

<p><img src="05_welcome-Listener/InsertOnEnable.png" alt="Select onEnable" /></p>

<p>Wie in der Abbildung vorgegeben, wählst du <strong>onEnable()</strong> aus und drückst auf <strong>Generate</strong>. Damit sollte deine Klasse ca. so aussehen:</p>

<pre>
public class Welcome extends JavaPlugin {

    @Override
    public void onEnable() {
        super.onEnable(); //To change body of generated methods, choose Tools | Templates.
    }
    
    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        sender.sendMessage("Hello " + sender.getName());
        return true;
    }
    
}
</pre>

<p><code>onCommand</code> muss in deiner Klasse nicht da sein, je nachdem, ob du für diese Episode ein neues Projekt angefangen hast oder nicht. Die Methode <code>onEnable</code> eines Plugins wird dann aufgerufen, wenn das Plugin geladen wird. Das ist meist nach dem (Neu-)Starten des Servers oder nachdem auf der Konsole das Kommando <code>reload</code> eingegeben wurde. Damit ist das der ideale Platz um unseren Listener zu registrieren. Bevor du deinen Code reinschreibst, löscht du am besten den Template-Code mit <code>super.onEnable(); ...</code> damit da ordentlich Platz ist.</p>

<p>Der Listener muss beim Server registriert werden und der bequeme Server delegiert das ganze gleich noch an den sog. <code>PluginManager</code>, aber alles der Reihe nach. Um auf den Server zuzugreifen, rufst du die Methode <code>getServer</code> auf (die gibts praktischerweise direkt im Plugin), dann rufst du vom Server die Methode <code>getPluginManager</code> auf und der wiederum hat die Methode <code>registerEvents</code>. Du kannst die Aufruffolge im nächsten Bild ansehen.</p>

<p><img src="05_welcome-Listener/SelectRegisterEvents.png" alt="Select onEnable" /></p>

<p>Du siehst, dass diese Methode zwei Parameter verlangt, nämlich einen Listener (was wir ja erwartet haben) und aber auch ein Plugin, dem dieser Listener zuzuordnen ist. Also los gehts: Den Listener haben wir ja gerade programmiert, den müssen wir nur noch erzeugen (das passiert mit dem Wörtchen <code>new</code>) und das Plugin, das gibt es ja bereits (in dieser Klasse befinden wir uns gerade) und wir müssen nur darauf verweisen (das passiert mit dem Wörtchen <code>this</code>). Zum Schluss sollte deine Methode genau so aussehen:</p>

<pre>
public void onEnable() {
    getServer().getPluginManager().registerEvents(new JoinAndLeaveListener(), this);
}
</pre>

<h3 id="auch-eine-schöne-verabschiedung">Auch eine schöne Verabschiedung</h3>

<p>Damit wir das mit den Event Handlern gleich ein wenig üben, schlage ich vor, dass wir noch einen zweiten Handler zur Verabschiedung, also wenn ein Spieler den Server verlässt, hinzufügen. Der Event heißt <code>PlayerQuitEvent</code>. Damit sollte aber genug gesagt sein und den Rest solltest du schon ganz allein hinbekommen. Die Auflösung gibts in der nächsten Episode.</p>

<h3 id="chat-messages-der-ops-hervorheben">Chat-Messages der ops hervorheben</h3>

<p>Wenn du die Verabschiedung auch schon fertig hast, probier doch noch folgendes: Wir wollen beim Chatten die ops besonders hervorheben, weil sie ja auch soooo superwichtig sind. Das heißt, dass Chat-Nachrichten normaler Spiele, wie üblich in der Farbe weiß dargestellt werden. Wenn aber ein op eine Nachricht sendet, soll diese in einer anderen Farbe (wie zum Beispiel im folgenden Screenshot) golden dargestellt werden.</p>

<p><img src="05_welcome-Listener/OpMessage.png" alt="Select onEnable" /></p>

<p>Natürlich bekommst du von mir noch ein paar sachdienliche Hinweise. Den Rest bekommst du dann sicherlich schon ganz gut alleine hin. Also, was brauchst du?</p>

<ol>
<li>Die Klasse: Da dieser Handler nichts mehr mit den Begrüßungen zu tun hat, find ich es gut, den Handler in eine neue Klasse zu geben. Ich schlage vor, du legst eine neue Klasse namens <code>ChatListener</code> an. Den Event Handler nennen wir <code>onChatMessageIsSent</code> würde ich vorschlagen.</li>
<li>Der Datentyp für den Parameter des Event Handlers: <code>AsyncPlayerChatEvent</code></li>
<li>Die Nachricht, die der Spieler eingegeben hat, auslesen: <code>AsyncPlayerChatEvent</code> hat dazu die Methode <code>getMessage</code></li>
<li>Die Nachricht golden einfärben: Dazu gibts den Typ <code>ChatColor</code>. Der stellt verschiedene Farbwerte und Schriftveränderungen zur Verfügung, die man einfach vor einen String kleben kann. Damit veränderst du die Darstellung des Strings. Beispiel: <code>ChatColor.GOLD + &quot;Hui&quot;</code> stellt &ldquo;Hui&rdquo; in goldener Farbe dar. <code>ChatColor.GOLD + &quot;&quot; + ChatColor.BOLD + &quot;Hui&quot;</code> stellt &ldquo;Hui&rdquo; fett und in der Farbe Gold dar. Beachte dabei, dass die &ldquo;echte Farbe&rdquo; zuerst kommen muss und dann erst die sonstigen Dekorationen wie <strong>bold</strong> order <em>italic</em>. Weiters musst du aufpassen, dass zwischen den <code>ChatColor</code>-Angaben immer ein leerer String (also <code>&quot;&quot;</code>) stehen muss. Sieh dir die verschiedenen Farben, die <code>ChatColor</code> zur Verfügung stellt, an und such dir eine aus.</li>
<li>Die Nachricht dann setzen: Achtung, die veränderte Nachricht &ldquo;händisch&rdquo; via sendMessage zu versenden würde nix bringen, da das ja nur an einen Spieler geht. Du müsstest dir ja alle Spieler vom Server holen und jedem einzelnen via <code>sendMessage</code> die Nachricht schicken. Das geht aber einfacher: Das Event hat auch eine Methode <code>setMessage</code>, mit der du die &ldquo;Originalnachricht&rdquo; durch die golden eingefärbte Nachricht ersetzen kannst und das Versenden der Message überlässt du wieder dem Server, der das ja sowieso machen wollte.</li>
<li>Da wir diesen Handler in eine eigene Listener-Klasse gegeben haben, musst du den im <code>onEnable</code> registrieren: <code>getServer().getPluginManager().registerEvents(new ChatListener(), this);</code></li>
</ol>

<p>Eine Sache find ich noch wichtig, dass du dir überlegst und du verstehst. Wenn ein Ereignis eintritt, macht der Bukkit-Server folgendes:</p>

<ol>
<li>Er baut ein Event-Objekt (die Rohrpost), das den Event beschreibt</li>
<li>Er schickt die Rohrpost an alle Plugins, diese können das Event-Objekt auslesen, verändern und was weiß ich noch alles machen</li>
<li>Sobald das letzte Plugin das Event-Objekt gehabt hat, führt der Server das Event endlich aus. Dazu nimmt er aber das von den Plugins veränderte Event-Objekt her.</li>
</ol>

<p>So, du hast nun einen großen Schritt gemacht und gelernt, wie du auf Ereignisse reagieren kannst. Damit stehen dir schon viele Möglichkeiten für deine eigenen Plugin-Ideen offen. In der nächsten Episode zeige ich dir noch eine Anwendung eines Listeners, indem wir unser Getafix-Plugin um einen Zaubertrank erweitern, der die Spielerin, die ihn getrunken hat, unbesiegbar macht.</p>

<p>Wenn du aber eigene Ideen hast, probier sie aus, besprich sie mit deinen MentorInnen und bleib hartnäckig dran, dann wird&rsquo;s bestimmt etwas.</p>

<h2 id="a-name-short-a-kurzversion-für-profis"><a name="short"></a>Kurzversion für Profis</h2>

<ol>
<li>Erstelle ein neues Projekt mit dem Namen <code>ListenerPlugin</code>, eine Klasse mit dem Namen <code>Welcome</code>, eine Klasse mit dem Namen <code>JoinAndLeaveListener</code> sowie das <code>plugin.yml</code> (siehe auch <a href="/trainingsanleitungen/minecraft-plugins/netbeans_cheatsheet.html">hier</a>)</li>

<li><p>Implementiere die Klasse <code>JoinAndLeaveListener</code>:
<pre>
public class JoinAndLeaveListener implements Listener {</p>
<pre><code>@EventHandler
public void onJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        player.sendMessage(&#34;Dear &#34; + player.getName() + &#34;, welcome to our server!&#34;);
}</code></pre>
<p>}
</pre></p></li>

<li><p>Registriere den Listener, indem du die Klasse <code>Welcome</code> implementierst:
<pre>
public class Welcome extends JavaPlugin {</p>
<pre><code>@Override
public void onEnable() {
    getServer().getPluginManager().registerEvents(new JoinAndLeaveListener(), this);
}

@Override
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
    sender.sendMessage(&#34;Hello &#34; + sender.getName());
    return true;
}</code></pre>
<p>}
</pre></p></li>

<li><p>Füge einen weiteren <code>EventHandler</code> zur Klasse <code>JoinAndLeaveListener</code>, und zwar einen <code>PlayerQuitEvent</code> mit einer dementsprechenden Nachricht.</p></li>

<li><p>Füge eine weitere Klasse namens <code>ChatListener</code> dazu und stelle sicher, dass nach dem Klassennamen <code>implements Listener</code> steht.</p></li>

<li><p>Füge die Methode <code>onChatMessageIsSent</code> hinzu, mit dem <code>event</code> Parameter vom Typ <code>AsyncPlayerChatEvent</code>, und gib über die Methode die Annotation <code>@EventHandler</code>.</p></li>

<li><p>Lese die Nachricht, die der Spieler eingegeben hat, <code>AsyncPlayerChatEvent</code> hat dazu die Methode <code>getMessage</code></p></li>

<li><p>Färbe die Nachricht golden ein (<code>ChatColor.GOLD + &quot;&quot; + event.getMessage()</code>) und schicke sie mit <code>sendMessage()</code> wieder an den Spieler zurück.</p></li>

<li><p>Da wir diesen Handler in eine eigene Listener-Klasse gegeben haben, musst du den im <code>onEnable</code> in der Klasse <code>Welcome</code> registrieren: <code>getServer().getPluginManager().registerEvents(new ChatListener(), this);</code></p></li>

<li><p>Baue das Paket: In Icon Leiste auf den Hammer <strong>Build Project (F11)</strong> klicken</p></li>

<li><p>Kopiere bzw. ersetze das fertige jar File aus <code>dist</code> (siehe Pfad im <strong>Output</strong>) in das Minecraft Server Plugin-Verzeichnis.</p></li>

<li><p>Starte den Server  oder gib <code>reload</code> in die Server Konsole ein.</p></li>

<li><p>Teste das Plugin: wenn du den Server betrittst bzw. verlässt, sollen deine Nachrichten angezeigt werden. Wenn du eine Nachricht als Operator schickst, soll diese golden angezeigt werden.</p></li>
</ol>
</p>
                    </div>
                    
                </div>
            </div>
            
        </div>
    </div>
</section>



    <footer>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <p>
                        Coding Club Linz,
                        Birkenweg 16,
                        4060 Leonding
                        <br />
                        <a href="mailto:info@linz.coderdojo.net">info@linz.coderdojo.net</a>
                    </p>
                </div>
            </div>
        </div>
    </footer>


    <!-- Js -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="https://linz-preview.coderdojo.net/js/wow.min.js"></script>
    <script src="https://linz-preview.coderdojo.net/js/main.js"></script>

</body>

</html>